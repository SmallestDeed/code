package com.sandu.onekey.service.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.sandu.common.properties.AppProperties;
import com.sandu.common.util.FileUploadUtils;
import com.sandu.common.util.Utils;
import com.sandu.common.util.collections.Lists;
import com.sandu.common.util.constant.Constants;
import com.sandu.design.model.DesignPlanRecommended;
import com.sandu.design.model.DesignPlanRecommendedProduct;
import com.sandu.design.model.DesignTemplet;
import com.sandu.design.model.DesignTempletProduct;
import com.sandu.design.model.constant.DesignPlanConstants;
import com.sandu.design.service.DesignPlanProductService;
import com.sandu.design.service.DesignPlanRecommendedProductService;
import com.sandu.design.service.DesignPlanRecommendedService;
import com.sandu.design.service.DesignTempletProductService;
import com.sandu.onekey.model.ProductListByTypeInfo;
import com.sandu.onekey.model.ProductListByTypeInfo.PlanGroupInfo;
import com.sandu.onekey.model.ProductListByTypeInfo.PlanProductInfo;
import com.sandu.onekey.model.ProductListByTypeInfo.PlanStructureInfo;
import com.sandu.onekey.model.contant.IntelligenceDecorationConstant;
import com.sandu.onekey.model.dto.BedroomProductMatchDTO;
import com.sandu.onekey.model.dto.BedroomProductMatchDTO.DetailInfo;
import com.sandu.onekey.model.dto.BedroomProductMatchDTO.GroupMatchInfoDTO;
import com.sandu.onekey.model.dto.BedroomProductMatchDTO.ProductMatchInfoDTO;
import com.sandu.onekey.model.dto.BedroomProductMatchDTO.StructureMatchInfoDTO;
import com.sandu.onekey.model.dto.BedroomProductMatchDTO.WallTypeConstant;
import com.sandu.onekey.model.vo.DimMatchInfoVO;
import com.sandu.onekey.model.vo.StructureDetailInfoVO;
import com.sandu.onekey.service.IntelligenceDecorationService;
import com.sandu.onekey.service.exception.IntelligenceDecorationException;
import com.sandu.onekey.service.exception.IntelligenceDecorationExceptionEnum;
import com.sandu.product.model.BaseProduct;
import com.sandu.product.model.GroupProduct;
import com.sandu.product.model.ProductPropsSimple;
import com.sandu.product.model.StructureProduct;
import com.sandu.product.model.constant.ProductUtilsConstant;
import com.sandu.product.model.constant.StructureProductConstant;
import com.sandu.product.model.dto.SplitTextureDTO;
import com.sandu.product.model.search.BaseProductSearch;
import com.sandu.product.model.search.StructureProductSearch;
import com.sandu.product.model.constant.ProductConstant.getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum;
import com.sandu.product.model.constant.ProductModelConstant;
import com.sandu.product.model.constant.ProductPropsConstant;
import com.sandu.product.model.constant.ProductTypeConstant;
import com.sandu.product.service.BaseProductService;
import com.sandu.product.service.GroupProductService;
import com.sandu.product.service.ProductPropsService;
import com.sandu.product.service.StructureProductService;
import com.sandu.system.model.ResFile;
import com.sandu.system.model.ResTexture;
import com.sandu.system.service.ResFileService;
import com.sandu.system.service.ResTextureService;
import com.sandu.system.service.SysDictionaryService;

@Service("intelligenceDecorationService")
public class IntelligenceDecorationServiceImpl implements IntelligenceDecorationService {

	private static Logger logger = LoggerFactory.getLogger(IntelligenceDecorationServiceImpl.class);
	
	@Autowired
	private GroupProductService groupProductService;
	
	@Autowired
	private BaseProductService baseProductService;
	
	@Autowired
	private SysDictionaryService sysDictionaryService;
	
	@Autowired
	private StructureProductService structureProductService;
	
	@Autowired
	private ResFileService resFileService;
	
	@Autowired
	private DesignPlanProductService designPlanProductService;
	
	@Autowired
	private DesignPlanRecommendedService designPlanRecommendedService;
	
	@Autowired
	private DesignTempletProductService designTempletProductService;
	
	@Autowired
	private DesignPlanRecommendedProductService designPlanRecommendedProductService;
	
	@Autowired
	private ProductPropsService productPropsService;
	
	@Autowired
	private ResTextureService resTextureService;
	
	// 白膜背景墙valukeyList
		private static List<String> beijingValuekeyList = Utils.getListFromStr(
				Utils.getValueByFileKey(AppProperties.APP, AppProperties.SMALLPRODUCTTYPE_BEIJINGWALL_FILEKEY, "basic_dians,basic_shaf,basic_cant,basic_chuangt,basic_xingx,basic_beij")
				);
	
	/**
	 * smallTypeInit:样板房的小类匹配推荐方案initProduct(初始白膜)的小类
	 * defaultType:匹配其他信息(对等信息,比如样板房region_mark和推荐方案region_mark匹配...)
	 * @author huangsongbo
	 *
	 */
	private enum checkDataFromMapEnum{
		defaultType
	}
	
	/**
	 * wallType 墙体分类
	 * wallOrientation 墙体方位
	 * groupType 是否是结构背景墙 0:否;1:是
	 * isMainStructureProduct 是否是主墙
	 * @author huangsongbo
	 *
	 */
	public enum deletedBeijingProductInfoMapKeyEnum {
		wallType, wallOrientation, groupType, isMainStructureProduct
	}
	
	private static int beijingRange = Integer.parseInt(Utils.getValue("app.filter.stretch.length", "10"));
	
	private String logPrefixClass = "function:IntelligenceDecorationServiceImpl.";
	
	private static List<Integer> beijingValueList = null;
	
	@Override
	public ProductListByTypeInfo getProductListByTypeInfo(
			List<DesignPlanRecommendedProduct> designPlanRecommendedProductList) throws IntelligenceDecorationException {
		
		// *参数验证 ->start
		if(designPlanRecommendedProductList == null || designPlanRecommendedProductList.size() == 0) {
			logger.error("------function:getProductListByTypeInfo(List<DesignPlanRecommendedProduct> designPlanRecommendedProductList)->(designPlanRecommendedProductList == null || designPlanRecommendedProductList.size() == 0) = true");
			return null;
		}
		// *参数验证 ->end
		
		List<ProductListByTypeInfo.PlanProductInfo> productList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
		
		// *结构信息 ->start
		PlanStructureInfo structureInfo = new ProductListByTypeInfo().new PlanStructureInfo();
		Map<String, PlanProductInfo> mainProudctMap = new HashMap<String, PlanProductInfo>();
		Map<String, List<PlanProductInfo>> structureProudctListMap = new HashMap<String, List<PlanProductInfo>>();
		Map<Integer, StructureProduct> structureProudctListMapCache = new HashMap<Integer, StructureProduct>();
		// *结构信息 ->end
		
		// *组合信息 ->start
		PlanGroupInfo groupInfo = new ProductListByTypeInfo().new PlanGroupInfo();
		Map<String, PlanProductInfo> groupMainProudctMap = new HashMap<String, PlanProductInfo>();
		Map<String, List<PlanProductInfo>> groupProudctListMap = new HashMap<String, List<PlanProductInfo>>();
		// *组合信息 ->end
		Map<String, List<PlanProductInfo>> productListMap = new HashMap<String, List<PlanProductInfo>>();
		
		/*// 组合id->组合类型的map
		Map<Integer, Integer> groupTypeMap = new HashMap<Integer, Integer>();*/
		// 组合id->组合信息的map
		Map<Integer, GroupProduct> groupInfoMap = new HashMap<Integer, GroupProduct>();
		
		// wallType优先级,优先级排序:由高到低:J,K,L
		// 注释原因:将此段代码转移到匹配背景墙方法中
		/*List<String> wallTypeScoreList = Arrays.asList(new String[] {"null", "L", "K", "J"});*/
		
		for(DesignPlanRecommendedProduct designPlanRecommendedProduct : designPlanRecommendedProductList) {
			// 去掉白膜
			if(designPlanRecommendedProduct != null && designPlanRecommendedProduct.getProductCode() != null && designPlanRecommendedProduct.getProductCode().startsWith("baimo_")) {
				continue;
			}
			
			PlanProductInfo planProductInfo = this.getPlanProductInfoFromDesignPlanRecommendedProduct(designPlanRecommendedProduct);
			
			/*if(1 == designPlanRecommendedProduct.getGroupType().intValue() && StringUtils.equals("dim", designPlanRecommendedProduct.getBigTypeValuekey())) {*/
			if(1 == designPlanRecommendedProduct.getGroupType().intValue() && 
					/*(StringUtils.equals("dim", designTempletProduct.getBigTypeValuekey()))*/
					/*排除结构背景墙*/
					ProductUtilsConstant.beijingValuekeyList.indexOf(designPlanRecommendedProduct.getSmallTypeValuekey()) == -1
					) {
				// 判断为结构(只要dim结构)
				String planGroupId = designPlanRecommendedProduct.getPlanGroupId();
				
				if(StringUtils.isEmpty(planGroupId) || StringUtils.equals("0", planGroupId.trim())){
					logger.error("------function:getProductListByTypeInfo(...)->\n"
							+ "存在group_type = 1 但是plan_group_id = null or plan_group_id = 0的数据,这种数据不允许出现");
				}else {
					this.setStructureProductInfo(planProductInfo, structureProudctListMapCache);
					if(mainProudctMap.containsKey(planGroupId)) {
						structureProudctListMap.get(planGroupId).add(planProductInfo);
					}else {
						mainProudctMap.put(planGroupId, planProductInfo);
						List<PlanProductInfo> planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
						planProductInfoList.add(planProductInfo);
						structureProudctListMap.put(planGroupId, planProductInfoList);
					}
				}
				// *也添加到单品中 ->start
				PlanProductInfo planProductInfoCopy = planProductInfo.clone();
				/*planProductInfoCopy.setPlanGroupId(null);
				planProductInfoCopy.setGroupType(null);*/
				productList.add(planProductInfoCopy);
				this.dealWithProductListMap(productListMap, planProductInfoCopy);
				// *也添加到单品中 ->end
			}else if(StringUtils.isNotEmpty(designPlanRecommendedProduct.getPlanGroupId()) 
					&& !StringUtils.equals("0", designPlanRecommendedProduct.getPlanGroupId())
					&& designPlanRecommendedProduct.getGroupType() != null && 0 == designPlanRecommendedProduct.getGroupType().intValue()) {
				// 判断为组合
				String planGroupId = designPlanRecommendedProduct.getPlanGroupId();
				
				// 获取组合类型
				/*Integer groupType = groupProductService.getGroupType(groupTypeMap, designPlanRecommendedProduct.getProductGroupId());
				planProductInfo.setGroupType(groupType);*/
				// 获取组合信息
				GroupProduct groupProduct = groupProductService.getGroupProductByCache(groupInfoMap, designPlanRecommendedProduct.getProductGroupId());
				if(groupProduct != null) {
					planProductInfo.setGroupType(groupProduct.getCompositeType());
					planProductInfo.setProductFilterPropList(groupProduct.getProductFilterPropList());
				}else{
					throw new IntelligenceDecorationException("推荐方案中某个组合被删除了,一键装修失败");
				}
				
				if(groupProudctListMap.containsKey(planGroupId)) {
					groupProudctListMap.get(planGroupId).add(planProductInfo);
				}else {
					List<PlanProductInfo> planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
					planProductInfoList.add(planProductInfo);
					groupProudctListMap.put(planGroupId, planProductInfoList);
				}
				// *也添加到单品中 ->start
				PlanProductInfo planProductInfoCopy = planProductInfo.clone();
				planProductInfoCopy.setPlanGroupId(null);
				planProductInfoCopy.setGroupType(null);
				String smallTypeValuekeyInit = planProductInfo.getSmallTypeValuekeyInit();
				if(StringUtils.isNotBlank(smallTypeValuekeyInit)) {
					smallTypeValuekeyInit = "basic_" + smallTypeValuekeyInit.replace("basic_", "");
					planProductInfoCopy.setSmallTypeValuekeyInit(smallTypeValuekeyInit);
				}
				productList.add(planProductInfoCopy);
				this.dealWithProductListMap(productListMap, planProductInfoCopy);
				// *也添加到单品中 ->end
			}else {
				// 判断为单品
				ProductListByTypeInfo.PlanProductInfo productListByTypeInfo = this.getPlanProductInfoFromDesignPlanRecommendedProduct(designPlanRecommendedProduct);
				// 配置背景墙匹配优先级
				/*String wallType = productListByTypeInfo.getWallType();
				if(StringUtils.isNotEmpty(wallType)) {
					productListByTypeInfo.setWallTypeScore(wallTypeScoreList.indexOf(wallType));
				}else {
					productListByTypeInfo.setWallTypeScore(-1);
				}*/
				productList.add(productListByTypeInfo);
				// 拼装productListMap
				this.dealWithProductListMap(productListMap, productListByTypeInfo);
			}
		}
		
		// *组装结构信息 ->start
		structureInfo.setMainProudctMap(mainProudctMap);
		structureInfo.setStructureProudctListMap(structureProudctListMap);
		// *组装结构信息 ->end
				
		// *组装组合信息 ->start
		// 组装groupMainProudctMap
		for(String key : groupProudctListMap.keySet()) {
			List<PlanProductInfo> planProductInfoList = groupProudctListMap.get(key);
			// 取出主产品
			PlanProductInfo planProductInfoMainProduct = null;
			for(PlanProductInfo planProductInfo : planProductInfoList) {
				if(planProductInfo.getIsMainProduct() != null && 1 == planProductInfo.getIsMainProduct().intValue()) {
					planProductInfoMainProduct = planProductInfo;
					break;
				}
			}
			if(planProductInfoMainProduct != null) {
				// 取出主产品对应的初始化白膜产品的过滤/需要参加匹配条件的属性(暂定为床头柜组合)
				if(StringUtils.equals("ca", planProductInfoMainProduct.getBigTypeValuekey()) 
						&& (StringUtils.equals("basic_beca", planProductInfoMainProduct.getSmallTypeValuekey()) || StringUtils.equals("beca", planProductInfoMainProduct.getSmallTypeValuekey()))) {
					planProductInfoMainProduct.setProductFilterPropList(
							baseProductService.getProductPropsSimpleByProductId(planProductInfoMainProduct.getInitProductId(), ProductModelConstant.PRODUCTATTRCODE_CHAOXIANG)
							);
				}
				groupMainProudctMap.put(key, planProductInfoMainProduct);
			}else {
				// 主产品都不见了...数据有错误,全部当单品处理
				logger.error("------function:getProductListByTypeInfo(....)->\n"
						+ "识别到样板房里的一个组合,主产品不见了,plan_product_id = " + key);
				for(PlanProductInfo planProductInfo : planProductInfoList) {
					productList.add(planProductInfo);
				}
			}
		}
		groupInfo.setGroupProudctListMap(groupProudctListMap);
		groupInfo.setMainProudctMap(groupMainProudctMap);
		// *组装组合信息 ->end
		
		ProductListByTypeInfo productListByTypeInfo = new ProductListByTypeInfo();
		productListByTypeInfo.setGroupInfo(groupInfo);
		productListByTypeInfo.setProductList(productList);
		productListByTypeInfo.setProductListMap(productListMap);
		productListByTypeInfo.setStructureInfo(structureInfo);
		
		return productListByTypeInfo;
	}

	@Override
	public Map<String, Object> structureListMatch(
			/*PlanStructureInfo planStructureInfo, */
			ProductListByTypeInfo productListByTypeInfo,
			PlanStructureInfo planStructureInfoRecommended, Integer planId,
			String username, Integer opType, Map<String, List<PlanProductInfo>> productListmap, String spaceCode, DesignTemplet designTemplet) throws IntelligenceDecorationException {
		// 参数验证/参数处理 ->start
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		// 暂时没用,用来以后扩展(处理不同房间类型不同的结构匹配逻辑)
		if(StringUtils.isEmpty(spaceCode)) {
			// 默认为卧室一件装修逻辑
			spaceCode = "D";
		}
		// 参数验证/参数处理 ->end
		
		List<StructureMatchInfoDTO> structureMatchInfoDTOList = null;
		
		/*if(spaceCode.startsWith(SpaceCommonConstant.HOUSETYPE_TOILET)) {
			// 卫生间结构匹配逻辑
			structureMatchInfoDTOList = structureListMatchToilet(productListByTypeInfo, planStructureInfoRecommended, planId, username, opType, productListmap);
		}else {
			// 默认是卧室结构匹配逻辑
			structureMatchInfoDTOList = structureListMatchBedroom(productListByTypeInfo, planStructureInfoRecommended, planId, username, opType, productListmap);
		}*/
		
		// 暂时是通用逻辑,并没有发现结构匹配逻辑有特殊点
		structureMatchInfoDTOList = this.structureListMatchBedroom(
				productListByTypeInfo, planStructureInfoRecommended,
				planId, username, 
				opType, productListmap, designTemplet);
		Map<String, Object> resultMap = new HashMap<String, Object>();
		resultMap.put(Constants.STRUCTURELISTMATCHRESULTMAPENUM_STRUCTUREMATCHINFO, structureMatchInfoDTOList);
		resultMap.put(Constants.STRUCTURELISTMATCHRESULTMAPENUM_PRODUCTLISTBYTYPEINFO, productListByTypeInfo);
		return resultMap;
	}

	@Override
	public Map<String, Object> groupListMatch(
			ProductListByTypeInfo productListByTypeInfo, PlanGroupInfo planGroupInfoRecommended, Integer planId, String username,
			Integer opType
		) {
		
		// 参数验证/参数处理 ->start
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		// 参数验证/参数处理 ->end
		
		Map<String, Object> resultMap = new HashMap<String, Object>();
		PlanGroupInfo planGroupInfo = productListByTypeInfo.getGroupInfo();
		//等待单品匹配逻辑的单品list
		List<PlanProductInfo> productMatchList = productListByTypeInfo.getProductList();
		
		List<GroupMatchInfoDTO> groupMatchInfoDTOList = new ArrayList<GroupMatchInfoDTO>();
	
		// *取出需要的信息 ->start
		Map<String, PlanProductInfo> templetGroupMainProudctMap = planGroupInfo.getMainProudctMap();
		Map<String, List<PlanProductInfo>> templetGroupProudctListMap = planGroupInfo.getGroupProudctListMap();
		Map<String, PlanProductInfo> planGroupMainProudctMap = planGroupInfoRecommended.getMainProudctMap();
		Map<String, List<PlanProductInfo>> planGroupProudctListMap = planGroupInfoRecommended.getGroupProudctListMap();
		// *取出需要的信息 ->end
		
		if(planGroupInfo.getMainProudctMap() != null) {
			for(String key : templetGroupMainProudctMap.keySet()) {
				GroupMatchInfoDTO groupMatchInfoDTO = new BedroomProductMatchDTO().new GroupMatchInfoDTO();
				PlanProductInfo templetMainPlanProductInfo = templetGroupMainProudctMap.get(key);
				// 记录组合匹配信息
				StringBuffer matchInfo = new StringBuffer("");
				String planGroupIdMatched = this.groupMatch(templetMainPlanProductInfo, planGroupMainProudctMap, matchInfo);
				if(StringUtils.isNotEmpty(planGroupIdMatched)) {
					groupMatchInfoDTO = this.getGroupMatchInfoDTO(planGroupProudctListMap.get(planGroupIdMatched), planGroupIdMatched, planId, username, opType);
				}else {
					// 组合没匹配上
					
					// add by huangsongbo 2018.5.3 特殊处理逻辑:电视柜组合没有匹配上,单独拿出电视做单品匹配,去匹配挂式电视 ->start
					Integer tvbenchSysDictionaryValue = sysDictionaryService.getTvbenchSysDictionaryValue();
					if(tvbenchSysDictionaryValue != null && templetMainPlanProductInfo.getGroupType() != null
							&& tvbenchSysDictionaryValue.intValue() == templetMainPlanProductInfo.getGroupType().intValue()) {
						
						// 将组合匹配信息剪切到单品匹配信息中 -> start
						List<PlanProductInfo> planProductInfoList = templetGroupProudctListMap.get(key);
						planProductInfoList.forEach(p -> {
							if(!StringUtils.equals("basic_tvel", p.getSmallTypeValuekey())) {
								// 非电视产品,全部删除
								p.setNeedBeMatched(false);
								p.setMatchInfo("电视柜组合匹配失败,删除该组合中所有除电视的产品");
							}else {
								// 电视产品,留着去匹配挂式电视
								/*p.setMatchFunctionEnum(MatchFunctionEnum.basic_tvel);*/
								p.setMatchFunction(IntelligenceDecorationConstant.MATCHFUNCTION_BASIC_TVEL);
							}
							productMatchList.add(p);
						});
						// 将组合匹配信息剪切到单品匹配信息中 -> end
						
					}
					// add by huangsongbo 2018.5.3 特殊处理逻辑:电视柜组合没有匹配上,单独拿出电视做单品匹配,去匹配挂式电视 ->end
					continue;
				}
				this.setSameInfo(groupMatchInfoDTO, templetGroupProudctListMap.get(key));
				groupMatchInfoDTO.setMainProductPosName(templetMainPlanProductInfo.getPosName());
				groupMatchInfoDTO.setMatchInfo(matchInfo.toString());
				groupMatchInfoDTOList.add(groupMatchInfoDTO);
			}
		}else {
			// 没有组合需要匹配
		}
		
		/*return groupMatchInfoDTOList;*/
		resultMap.put(IntelligenceDecorationConstant.GROUPMATCHRESULTMAP_GROUPMATCHINFO, groupMatchInfoDTOList);
		resultMap.put(IntelligenceDecorationConstant.GROUPMATCHRESULTMAP_PRODUCTLISTBYTYPEINFO, productListByTypeInfo);
		return resultMap;
	}

	@Override
	public Map<String, Object> productListMatch(
			List<PlanProductInfo> templetProductList,
			Map<String, List<PlanProductInfo>> productListmap, 
			PlanStructureInfo recommendedPlanStructureInfo, 
			Integer planId, 
			String username, 
			Integer matchType, 
			Integer opType, 
			DesignTemplet designTemplet,
			Integer planRecommendedId
		) throws IntelligenceDecorationException {
		
		Map<String, Object> returnMap = new HashMap<String, Object>();
		List<ProductMatchInfoDTO> productMatchInfoDTOList = new ArrayList<BedroomProductMatchDTO.ProductMatchInfoDTO>();
		List<DimMatchInfoVO> dimMatchInfoVOList = new ArrayList<DimMatchInfoVO>();
		
		// *参数验证 ->start
		if(Lists.isEmpty(templetProductList)) {
			return null;
		}
		if(productListmap == null) {
			return null;
		}
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		// *参数验证 ->end
		
		// 记录下所有背景墙信息,后面再特殊匹配
		List<PlanProductInfo> beijingPlanProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
		
		// 记录下所有挂画信息,后面再特殊匹配
		List<PlanProductInfo> pipePlanProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
		
		// 存系列产品,用来后面单独匹配(系列标识:样板房产品信息)(系列标识:该系列标识对应的样板房产品list)
		Map<String, List<PlanProductInfo>> seriesProductInfoMap = new HashMap<String, List<PlanProductInfo>>();
		
		for(PlanProductInfo planProductInfo : templetProductList) {
			
			logger.debug("posName:" + planProductInfo.getPosName());
			
			PlanProductInfo planProductInfoMatched = null;
			
			ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
			productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
			
			// add by huangsongbo 2018.5.3 特殊处理逻辑:电视柜组合没有匹配上,单独拿出电视做单品匹配,去匹配挂式电视 ->start
			if(!planProductInfo.isNeedBeMatched()) {
				this.getProductMatchInfoDTO(planId, username, opType, planProductInfo, new StringBuffer(planProductInfo.getMatchInfo()), productMatchInfoDTO, planProductInfoMatched);
				productMatchInfoDTOList.add(productMatchInfoDTO);
				continue;
			}
			// add by huangsongbo 2018.5.3 特殊处理逻辑:电视柜组合没有匹配上,单独拿出电视做单品匹配,去匹配挂式电视 ->end
			
			// 组装系列产品,放到后面去匹配 ->start
			String seriesSign = planProductInfo.getSeriesSign();
			if(StringUtils.isNotEmpty(seriesSign)){
				// 硬装替换,不需要进行系列匹配(默认系列都是软装)
				if(seriesProductInfoMap.containsKey(seriesSign)) {
					List<PlanProductInfo> planProductInfoList = seriesProductInfoMap.get(seriesSign);
					if(Lists.isNotEmpty(planProductInfoList)) {
						planProductInfoList.add(planProductInfo);
					}else {
						planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
						planProductInfoList.add(planProductInfo);
						seriesProductInfoMap.put(seriesSign, planProductInfoList);
					}
				}else {
					List<PlanProductInfo> planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
					planProductInfoList.add(planProductInfo);
					seriesProductInfoMap.put(seriesSign, planProductInfoList);
				}
				continue;
			}
			// 组装系列产品,放到后面去匹配 ->end
			
			StringBuffer matchInfo = new StringBuffer("");
			
			matchInfo.append("正在匹配:posName:" + planProductInfo.getPosName() + ";baseProductCode:" + planProductInfo.getProductCode() + "\n");
			logger.debug("posName:" + planProductInfo.getPosName());
			// *参数验证 ->start
			if(StringUtils.isEmpty(planProductInfo.getBigTypeValuekey())) {
				continue;
			}
			// *参数验证 ->end
			
			// 用于debug(最后要删除) ->start
//			if(StringUtils.isNotEmpty(IntelligenceDecorationController.posNameDebug)) {
//				if(StringUtils.equals(IntelligenceDecorationController.posNameDebug, planProductInfo.getPosName())) {
//					logger.debug("debug");
//				}
//			}
			// 用于debug(最后要删除) ->end
			
			// 决定要不要执行productMatchInfoDTOList.add(productMatchInfoDTO)
			// flag = true:添加productMatchInfoDTO;flag = false:检测到匹配为特殊背景墙匹配逻辑,放在后面再特殊匹配
			// 为了后面再特殊处理背景墙(匹配背景墙逻辑特殊,先匹配小类,匹配剩下的再按优先级(背景墙小类有一个小类优先级)匹配)
			/*boolean flag = true;*/
			
			String bigTypeValuekey = planProductInfo.getBigTypeValuekey();
			String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
			List<PlanProductInfo> theSameBigTypePlanProductInfoList = null;
			
			if(productListmap.containsKey(bigTypeValuekey)) {
				theSameBigTypePlanProductInfoList = productListmap.get(bigTypeValuekey);
			}
			
			if(0 == matchType) {
				// 水龙头的话,可能推荐方案中没有,也要匹配
				if(Lists.isEmpty(theSameBigTypePlanProductInfoList) && StringUtils.equals(ProductTypeConstant.PRODUCT_SMALL_TYPE_LYBP, smallTypeValuekey)) {
					// 未检测到推荐方案中有同大类的产品
					matchInfo.append("匹配失败(未检测到推荐方案有该白膜对应的大类)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					productMatchInfoDTO.setMatchInfo(matchInfo.toString());
					productMatchInfoDTOList.add(productMatchInfoDTO);
					continue;
				}
			}
			
			// *匹配地面->start
			if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_DIM, bigTypeValuekey)) {
				if(0 != matchType && (StringUtils.equals("basic_dit", smallTypeValuekey) || StringUtils.equals("dit", smallTypeValuekey))) {
					// 硬装替换的话,地毯不算硬装,特殊处理 ->start
					planProductInfoMatched = planProductInfo.clone();
					// 硬装替换的话,地毯不算硬装,特殊处理 ->end
				}else {
					// 户型绘制新逻辑 add by huangsongbo 2018.3.16 ->start
					// 区域标识匹配
					// 识别匹配上的地面是不是结构
					// 如果是结构,取出结构信息,组装返回数据
					
					// 以下小类的dim,可能是结构
					List<String> dimTypeList = new ArrayList<String>();
					dimTypeList.add(ProductTypeConstant.PRODUCT_SMALL_TYPE_BASIC_DIMZ);
					dimTypeList.add(ProductTypeConstant.PRODUCT_SMALL_TYPE_BASIC_DIM);
					dimTypeList.add(ProductTypeConstant.PRODUCT_SMALL_TYPE_BASIC_DIMGD);
					dimTypeList.add(ProductTypeConstant.PRODUCT_SMALL_TYPE_BASIC_DIMXG);
					if(dimTypeList.indexOf(planProductInfo.getSmallTypeValuekey()) != -1) {
						Map<String, Object> productListMatchDimResultMap= this.productListMatchDimV2(planProductInfo, theSameBigTypePlanProductInfoList, recommendedPlanStructureInfo, matchInfo, dimTypeList);
						if(productListMatchDimResultMap != null) {
							planProductInfoMatched = (PlanProductInfo) productListMatchDimResultMap.get(IntelligenceDecorationConstant.PRODUCTLISTMATCHDIMRESULTMAP_PLANPRODUCTINFO);
							DimMatchInfoVO dimMatchInfoVO = (DimMatchInfoVO) productListMatchDimResultMap.get(IntelligenceDecorationConstant.PRODUCTLISTMATCHDIMRESULTMAP_DIMMATCHINFOVO);
							if(dimMatchInfoVO != null) {
								dimMatchInfoVOList.add(dimMatchInfoVO);
							}
						}
					}else {
						planProductInfoMatched = this.productListMatchDim(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
					}
					// 户型绘制新逻辑 add by huangsongbo 2018.3.16 ->end
				}
			}
			// *匹配地面->end
			
			// *匹配门->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_MENG, bigTypeValuekey)) {
				planProductInfoMatched = this.productListMatchMeng(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
			}
			// *匹配门->start
			
			// *匹配墙面 ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM, bigTypeValuekey)) {
				if(ProductUtilsConstant.beijingValuekeyList.indexOf(smallTypeValuekey) != -1) {
					// *背景墙特殊处理(处理完其他的单品,再单独处理背景墙list) ->start
					beijingPlanProductInfoList.add(planProductInfo);
					continue;
					/*flag = false;*/
					// *背景墙特殊处理(处理完其他的单品,再单独处理背景墙list) ->end
				}else {
					// 其他qiangm
					planProductInfoMatched = this.productListMatchQiangm(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}

			}
			// *匹配墙面 ->end
			
			// *匹配天花 ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_TIANH, bigTypeValuekey)) {
				/*planProductInfoMatched = productListMatchTianh(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo, designTemplet.getSmallpoxIdentify());*/
				planProductInfoMatched = this.productListMatchTianhForDrawHouse(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo, designTemplet.getSmallpoxIdentify());
			}
			// *匹配天花 ->end
			
			// *匹配家纺 ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_HO, bigTypeValuekey)) {
				if(0 == matchType) {
					planProductInfoMatched = this.productListMatchHo(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// *匹配家纺 ->end
			
			// 匹配柜子 ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_CA, bigTypeValuekey)) {
				if(0 == matchType) {
					planProductInfoMatched = this.productListMatchCa(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// 匹配柜子 ->end
			
			// 匹配卫浴(淋浴房) ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_BA, bigTypeValuekey)) {
				if(0 == matchType) {
					planProductInfoMatched = this.productListMatchBa(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// 匹配卫浴(淋浴房) ->end
			
			// 厨房配件匹配(水槽) ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_KP, bigTypeValuekey)) {
				if(0 == matchType) {
					planProductInfoMatched = this.productListMatchKp(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// 厨房配件匹配(水槽) ->end
			
			// 浴室配件匹配(主要是水龙头) ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_BP, bigTypeValuekey)) {
				if(0 == matchType) {
					planProductInfoMatched = this.productListMatchBp(planProductInfo, productListmap, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// 浴室配件匹配(主要是水龙头)  ->end
			
			// 饰品(主要是挂画)匹配逻辑 ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_PE, bigTypeValuekey)) {
				if(0 == matchType) {
					
					// 挂画放到后面单独匹配 ->start
					if(StringUtils.equals(ProductTypeConstant.PRODUCT_SMALL_TYPE_BASIC_PIPE, smallTypeValuekey)){
						pipePlanProductInfoList.add(planProductInfo);
						continue;
					}
					// 挂画放到后面单独匹配 ->end
					
					planProductInfoMatched = this.productListMatchOther(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// 饰品(主要是挂画)匹配逻辑 ->end
			
			// 大家电 add by huangsongbo 2018.5.3 ->start
			else if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_EL, bigTypeValuekey)) {
				if(0 == matchType) {
					planProductInfoMatched = this.productListMatchEL(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// 大家电 add by huangsongbo 2018.5.3 ->end
			
			// *其他大类 ->start
			else {
				if(0 == matchType) {
					planProductInfoMatched = this.productListMatchOther(planProductInfo, theSameBigTypePlanProductInfoList, matchInfo);
				}else {
					planProductInfoMatched = planProductInfo.clone();
				}
			}
			// *其他大类 ->end
			
			/*if(flag) {*/
			// 添加设计方案产品数据
			this.getProductMatchInfoDTO(planId, username, opType, planProductInfo, matchInfo, productMatchInfoDTO, planProductInfoMatched);
			productMatchInfoDTOList.add(productMatchInfoDTO);
			/*}*/
			
		}
		
		// 再特殊处理背景墙 ->start
		List<PlanProductInfo> theSameBigTypePlanProductInfoList = null;
		if(productListmap.containsKey(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM)) {
			theSameBigTypePlanProductInfoList = productListmap.get(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM);
		}
		// 只保留背景墙
		for (int index = 0; index < theSameBigTypePlanProductInfoList.size(); index++) {
			if(ProductUtilsConstant.beijingValuekeyList.indexOf(theSameBigTypePlanProductInfoList.get(index).getSmallTypeValuekey()) != -1) {
				
			}else {
				theSameBigTypePlanProductInfoList.remove(index);
				index --;
			}
		}
		
		this.productListMatchBeijingQiangm(beijingPlanProductInfoList, theSameBigTypePlanProductInfoList, productMatchInfoDTOList, planId, username, opType, planRecommendedId);
		// 再特殊处理背景墙 ->end
		
		// 特殊处理挂画 ->start
		/*this.productListMatchPipe(pipePlanProductInfoList, productListmap, productMatchInfoDTOList, planId, username, opType, planRecommendedId);*/
		this.productListMatchPipeV2(pipePlanProductInfoList, productListmap.get(ProductTypeConstant.PRODUCT_BIG_TYPE_PE), productMatchInfoDTOList, planId, username, opType);
		// 特殊处理挂画 ->end
		
		// 特殊处理系列产品 ->start
		this.productListMatchSeries(seriesProductInfoMap, productListmap, productMatchInfoDTOList, planId, username, opType, matchType);
		// 特殊处理系列产品 ->end
		
		returnMap.put(IntelligenceDecorationConstant.PRODUCTLISTMATCHRESULTMAP_PRODUCTMATCHINFO, productMatchInfoDTOList);
		returnMap.put(IntelligenceDecorationConstant.PRODUCTLISTMATCHRESULTMAP_DIMMATCHINFOVO, dimMatchInfoVOList);
		
		return returnMap;
	}

	@Override
	public ProductListByTypeInfo getProductListByTypeInfo(
			List<DesignTempletProduct> designTempletProductList, 
			Integer matchType,
			Integer planRecommendedId
			) {
		
		// *参数验证 ->start
		if(designTempletProductList == null || designTempletProductList.size() == 0) {
			logger.error("------function:getProductListByTypeInfo(List<DesignTempletProduct> designTempletProductList)->(designTempletProductList == null || designTempletProductList.size() == 0) = true");
			return null;
		}
		if(matchType == null) {
			return null;
		}
		if(planRecommendedId == null){
			return null;
		}
		// *参数验证 ->end
		
		List<ProductListByTypeInfo.PlanProductInfo> productList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
		
		// *结构信息 ->start
		PlanStructureInfo structureInfo = new ProductListByTypeInfo().new PlanStructureInfo();
		Map<String, PlanProductInfo> structureMainProudctMap = new HashMap<String, PlanProductInfo>();
		Map<String, List<PlanProductInfo>> structureProudctListMap = new HashMap<String, List<PlanProductInfo>>();
		Map<Integer, StructureProduct> structureProudctListMapCache = new HashMap<Integer, StructureProduct>();
		// *结构信息 ->end
		
		// *组合信息 ->start
		PlanGroupInfo groupInfo = new ProductListByTypeInfo().new PlanGroupInfo();
		Map<String, PlanProductInfo> groupMainProudctMap = new HashMap<String, PlanProductInfo>();
		Map<String, List<PlanProductInfo>> groupProudctListMap = new HashMap<String, List<PlanProductInfo>>();
		// *组合信息 ->end
		
		/*// 组合id->组合类型的map
		Map<Integer, Integer> groupTypeMap = new HashMap<Integer, Integer>();*/
		// 组合id->组合信息的map
		Map<Integer, GroupProduct> groupInfoMap = new HashMap<Integer, GroupProduct>();
		
		// 检测推荐方案中有没有定制浴室柜,如果有的话,会进行特殊逻辑处理:样板房的浴室柜组合变成单品匹配逻辑 ->start
		boolean isRemmendedPlanHasDyba = designPlanRecommendedService.getIsRemmendedPlanHasDyba(planRecommendedId);
		// 检测推荐方案中有没有定制浴室柜,如果有的话,会进行特殊逻辑处理:样板房的浴室柜组合变成单品匹配逻辑 ->end
		
		for(DesignTempletProduct designTempletProduct : designTempletProductList) {
			
			logger.debug("posName:" + designTempletProduct.getPosName());
			
			PlanProductInfo planProductInfo = this.getPlanProductInfoFromDesignTempletProduct(designTempletProduct);
			logger.debug("posName:" + planProductInfo.getPosName());
			if(1 == designTempletProduct.getGroupType().intValue() && 
					/*(StringUtils.equals("dim", designTempletProduct.getBigTypeValuekey()))*/
					/*排除结构背景墙*/
					beijingValuekeyList.indexOf(designTempletProduct.getSmallTypeValuekey()) == -1
					// 户型绘制功能上线之后,地面结构匹配不走结构匹配逻辑 update by huangsongbo 2018.3.16
					&& !(StringUtils.equals("dim", designTempletProduct.getBigTypeValuekey()))
					) {
				// 判断为结构(只要dim结构)
				String planGroupId = designTempletProduct.getPlanGroupId();
				if(StringUtils.isEmpty(planGroupId) || StringUtils.equals("0", planGroupId.trim())){
					logger.error("------function:getProductListByTypeInfo(List<DesignTempletProduct> designTempletProductList)->\n"
							+ "存在group_type = 1 但是plan_group_id = null or plan_group_id = 0的数据,这种数据不允许出现");
				}else {
					// 设置结构信息(布局标识)
					this.setStructureProductInfo(planProductInfo, structureProudctListMapCache);
					if(structureMainProudctMap.containsKey(planGroupId)) {
						structureProudctListMap.get(planGroupId).add(planProductInfo);
					}else {
						structureMainProudctMap.put(planGroupId, planProductInfo);
						List<PlanProductInfo> planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
						planProductInfoList.add(planProductInfo);
						structureProudctListMap.put(planGroupId, planProductInfoList);
					}
				}
			}else if(StringUtils.isNotEmpty(designTempletProduct.getPlanGroupId()) 
					&& !StringUtils.equals("0", designTempletProduct.getPlanGroupId())
					&& designTempletProduct.getGroupType() != null && 0 == designTempletProduct.getGroupType().intValue()) {
				// 判断为组合
				// 区别与硬装替换和全屋替换
				if(0 == matchType.intValue()) {
					// 全屋替换
					String planGroupId = designTempletProduct.getPlanGroupId();
					
					/*// 获取组合类型
					Integer groupType = groupProductService.getGroupType(groupTypeMap, designTempletProduct.getProductGroupId());
					planProductInfo.setGroupType(groupType);*/
					// 获取组合信息
					GroupProduct groupProduct = groupProductService.getGroupProductByCache(groupInfoMap, designTempletProduct.getProductGroupId());
					if(groupProduct != null) {
						planProductInfo.setGroupType(groupProduct.getCompositeType());
						/*planProductInfo.setProductFilterPropList(groupProduct.getProductFilterPropList());*/
						// 浴室柜组合特殊处理:如果推荐方案中有定制浴室柜,把样板房中的浴室柜组合当作单品处理 ->start
						// 浴室柜组合value = 9
						if(isRemmendedPlanHasDyba && groupProduct.getCompositeType() != null && Constants.groupTypeValueYushigui.intValue() == groupProduct.getCompositeType().intValue()) {
							productList.add(planProductInfo);
							continue;
						}
						// 浴室柜组合特殊处理:如果推荐方案中有定制浴室柜,把样板房中的浴室柜组合当作单品处理 ->end
					}
					if(groupProudctListMap.containsKey(planGroupId)) {
						groupProudctListMap.get(planGroupId).add(planProductInfo);
					}else {
						List<PlanProductInfo> planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
						planProductInfoList.add(planProductInfo);
						groupProudctListMap.put(planGroupId, planProductInfoList);
					}
				}else {
					// 硬装替换,组合放在单品匹配列表里面
					productList.add(planProductInfo);
				}
			}else {
				// 判断为单品
				// 获取系列标识
				String seriesSign = baseProductService.getSeriesSign(planProductInfo.getSmallTypeValuekey());
				planProductInfo.setSeriesSign(seriesSign);
				productList.add(planProductInfo);
			}
		}
		
		// *组装结构信息 ->start
		structureInfo.setMainProudctMap(structureMainProudctMap);
		structureInfo.setStructureProudctListMap(structureProudctListMap);
		// *组装结构信息 ->end
		
		// *组装组合信息 ->start
		// 组装groupMainProudctMap
		for(String key : groupProudctListMap.keySet()) {
			List<PlanProductInfo> planProductInfoList = groupProudctListMap.get(key);
			// 取出主产品
			PlanProductInfo planProductInfoMainProduct = null;
			for(PlanProductInfo planProductInfo : planProductInfoList) {
				if(planProductInfo.getIsMainProduct() != null && 1 == planProductInfo.getIsMainProduct().intValue()) {
					planProductInfoMainProduct = planProductInfo;
					break;
				}
			}
			if(planProductInfoMainProduct != null) {
				// 取出主产品对应的初始化白膜产品的过滤/需要参加匹配条件的属性(暂定为床头柜组合)
				if(StringUtils.equals("ca", planProductInfoMainProduct.getBigTypeValuekey()) 
						&& (StringUtils.equals("basic_beca", planProductInfoMainProduct.getSmallTypeValuekey()) || StringUtils.equals("beca", planProductInfoMainProduct.getSmallTypeValuekey()))) {
					planProductInfoMainProduct.setProductFilterPropList(
							baseProductService.getProductPropsSimpleByProductId(planProductInfoMainProduct.getInitProductId(), ProductModelConstant.PRODUCTATTRCODE_CHAOXIANG)
							);
				}
				groupMainProudctMap.put(key, planProductInfoMainProduct);
			}else {
				// 主产品都不见了...数据有错误,全部当单品处理
				logger.error("------function:getProductListByTypeInfo(....)->\n"
						+ "识别到样板房里的一个组合,主产品不见了,plan_product_id = " + key);
				for(PlanProductInfo planProductInfo : planProductInfoList) {
					productList.add(planProductInfo);
				}
			}
		}
		groupInfo.setGroupProudctListMap(groupProudctListMap);
		groupInfo.setMainProudctMap(groupMainProudctMap);
		// *组装组合信息 ->end
		
		ProductListByTypeInfo productListByTypeInfo = new ProductListByTypeInfo();
		productListByTypeInfo.setGroupInfo(groupInfo);
		productListByTypeInfo.setProductList(productList);
		productListByTypeInfo.setStructureInfo(structureInfo);
		
		return productListByTypeInfo;
	}

	private PlanProductInfo getPlanProductInfoFromDesignPlanRecommendedProduct(
			DesignPlanRecommendedProduct designPlanRecommendedProduct) {
		PlanProductInfo planProductInfo = new PlanProductInfo();
		planProductInfo.setProductId(designPlanRecommendedProduct.getProductId());
		planProductInfo.setBigTypeValuekey(designPlanRecommendedProduct.getBigTypeValuekey());
		planProductInfo.setSmallTypeValuekey(designPlanRecommendedProduct.getSmallTypeValuekey());
		planProductInfo.setPosName(designPlanRecommendedProduct.getPosName());
		planProductInfo.setBigTypeValuekeyInit(designPlanRecommendedProduct.getBigTypeValuekeyInit());
		planProductInfo.setSmallTypeValuekeyInit(designPlanRecommendedProduct.getSmallTypeValuekeyInit());
		planProductInfo.setProductCode(designPlanRecommendedProduct.getProductCode());
		planProductInfo.setProductLength(designPlanRecommendedProduct.getProductLength());
		planProductInfo.setProductWidth(designPlanRecommendedProduct.getProductWidth());
		planProductInfo.setProductHeight(designPlanRecommendedProduct.getProductHeight());
		planProductInfo.setRegionMark(designPlanRecommendedProduct.getRegionMark());
		planProductInfo.setWallOrientation(designPlanRecommendedProduct.getWallOrientation());
		planProductInfo.setWallType(designPlanRecommendedProduct.getWallType());
		planProductInfo.setIsMainProduct(designPlanRecommendedProduct.getIsMainProduct());
		planProductInfo.setPlanGroupId(designPlanRecommendedProduct.getPlanGroupId());
		planProductInfo.setMeasureCode(designPlanRecommendedProduct.getMeasureCode());
		planProductInfo.setBindParentProductId(designPlanRecommendedProduct.getBindParentProductId());
		planProductInfo.setSplitTexturesChooseInfo(designPlanRecommendedProduct.getSplitTexturesChooseInfo());
		planProductInfo.setIsStandard(designPlanRecommendedProduct.getIsStandard());
		planProductInfo.setStyleId(designPlanRecommendedProduct.getStyleId());
		planProductInfo.setProductIndex(designPlanRecommendedProduct.getProductIndex());
		planProductInfo.setIsMainStructureProduct(designPlanRecommendedProduct.getIsMainStructureProduct());
		planProductInfo.setIsGroupReplaceWay(designPlanRecommendedProduct.getIsGroupReplaceWay());
		planProductInfo.setInitProductId(designPlanRecommendedProduct.getInitProductId());
		planProductInfo.setGroupProductUniqueId(designPlanRecommendedProduct.getGroupProductUniqueId());
		planProductInfo.setProductSmallpoxIdentify(designPlanRecommendedProduct.getProductSmallpoxIdentify());
		planProductInfo.setBrandId(designPlanRecommendedProduct.getBrandId());
		planProductInfo.setProductModelNumber(designPlanRecommendedProduct.getProductModelNumber());
		planProductInfo.setSeriesId(designPlanRecommendedProduct.getSeriesId());
		planProductInfo.setMatchedPosName(designPlanRecommendedProduct.getPosName());
		return planProductInfo;
	}
	
	/**
	 * 设置结构信息 to planProductInfo(结构布局标识)
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param structureProudctListMapCache
	 */
	private void setStructureProductInfo(PlanProductInfo planProductInfo,
			Map<Integer, StructureProduct> structureProudctListMapCache) {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return;
		}
		if(structureProudctListMapCache == null) {
			return;
		}
		// 参数验证 ->end
		
		/*Integer structureId = planProductInfo.getGroupOrStructureId();*/
		Integer structureId = null;
		String planStructureId = planProductInfo.getPlanGroupId();
		if(StringUtils.isNotEmpty(planStructureId)) {
			try {
				structureId = Integer.valueOf(planStructureId.split("_")[0]);
			}catch (Exception e) {
				
			}
		}
		if(structureId != null) {
			if(structureProudctListMapCache.containsKey(structureId)) {
				StructureProduct structureProduct = structureProudctListMapCache.get(structureId);
				if(structureProduct != null) {
					planProductInfo.setStructureProductSmallpoxIdentify(structureProduct.getStructureGroundIdentify());
				}
			}else {
				StructureProduct structureProduct = structureProductService.get(structureId);
				if(structureProduct != null) {
					planProductInfo.setStructureProductSmallpoxIdentify(structureProduct.getStructureGroundIdentify());
					structureProudctListMapCache.put(structureId, structureProduct);
				}
			}
		}
		
	}
	
	/**
	 * 组装Map<String, List<PlanProductInfo>> productListMap
	 * productListMap格式:Map<大类valuekey, 产品list>
	 * 
	 * @author huangsongbo
	 * @param productListMap
	 * @param productListByTypeInfo
	 */
	private void dealWithProductListMap(Map<String, List<PlanProductInfo>> productListMap,
			PlanProductInfo productListByTypeInfo) {
		String bigTypeValuekey = productListByTypeInfo.getBigTypeValuekey();
		if(productListMap.containsKey(bigTypeValuekey)) {
			List<PlanProductInfo> planProductInfoList = productListMap.get(bigTypeValuekey);
			planProductInfoList.add(productListByTypeInfo);
		}else {
			List<ProductListByTypeInfo.PlanProductInfo> planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
			planProductInfoList.add(productListByTypeInfo);
			productListMap.put(bigTypeValuekey, planProductInfoList);
		}
	}
	
	/**
	 * 卧室结构匹配逻辑
	 * 
	 * @author huangsongbo
	 * @param productListByTypeInfo
	 * @param planStructureInfoRecommended
	 * @param planId
	 * @param username
	 * @param opType
	 * @param productListmap
	 * @param designTemplet 样板房信息
	 * @return
	 * @throws IntelligenceDecorationException 
	 */
	private List<StructureMatchInfoDTO> structureListMatchBedroom(
			ProductListByTypeInfo productListByTypeInfo,
			PlanStructureInfo planStructureInfoRecommended, Integer planId,
			String username, Integer opType, Map<String, List<PlanProductInfo>> productListmap,
			DesignTemplet designTemplet) throws IntelligenceDecorationException {
		
		// 参数验证/参数处理 ->start
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		// 参数验证/参数处理 ->end
		
		List<StructureMatchInfoDTO> structureMatchInfoDTOList = new ArrayList<BedroomProductMatchDTO.StructureMatchInfoDTO>();
		
		// *取出需要的信息 ->start
		PlanStructureInfo planStructureInfo = productListByTypeInfo.getStructureInfo();
		Map<String, PlanProductInfo> templetStructureMainProudctMap = planStructureInfo.getMainProudctMap();
		Map<String, List<PlanProductInfo>> templetStructureProudctListMap = planStructureInfo.getStructureProudctListMap();
		Map<String, PlanProductInfo> planStructureMainProudctMap = planStructureInfoRecommended.getMainProudctMap();
		Map<String, List<PlanProductInfo>> planStructureProudctListMap = planStructureInfoRecommended.getStructureProudctListMap();
		// *取出需要的信息 ->end
		
		if(planStructureInfo.getMainProudctMap() != null) {
			for(String key : templetStructureMainProudctMap.keySet()) {
				StructureMatchInfoDTO structureMatchInfoDTO = new BedroomProductMatchDTO().new StructureMatchInfoDTO();
				PlanProductInfo templetMainPlanProductInfo = templetStructureMainProudctMap.get(key);
				// 记录结构匹配信息
				StringBuffer matchInfo = new StringBuffer("");
				matchInfo.append("正在匹配结构(plan_group_id:" + key + ")\n");
				/*List<PlanProductInfo> planProductInfoListMatched = this.structureMatch(
						templetMainPlanProductInfo, planStructureMainProudctMap, matchInfo,
						planStructureProudctListMap, productListmap, designTemplet.getId(), designTemplet.getGroundIdentify()
						);*/
				Map<String, Object> structureMatchReturnMap = this.structureMatch(
						templetMainPlanProductInfo, planStructureMainProudctMap, matchInfo,
						planStructureProudctListMap, productListmap, designTemplet.getId(), designTemplet.getGroundIdentify()
						);
				@SuppressWarnings("unchecked")
				List<PlanProductInfo> planProductInfoListMatched = (List<PlanProductInfo>) structureMatchReturnMap.get(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANPRODUCTINFOLISTMATCHED);
				if(Lists.isNotEmpty(planProductInfoListMatched)) {
					// 匹配/搜索到了结构,insert设计方案产品,并组装结构返回数据
					structureMatchInfoDTO = this.getStructureMatchInfoDTO(
							planProductInfoListMatched,
							planId, username, templetMainPlanProductInfo.getCenter(),
							templetMainPlanProductInfo.getRegionMark(), templetMainPlanProductInfo.getMeasureCode(),
							opType,
							(Integer) structureMatchReturnMap.get(Constants.STRUCTUREMATCHRETURNMAPKEY_PRODUCTSTRUCTUREID),
							(String) structureMatchReturnMap.get(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANSTRUCTUREREGIONMARK)
							);
				}else {
					// 没有匹配/搜索到结构
					// 通知数据组录数据,做一个容错处理,将样板房中该结构当作单品匹配
					matchInfo.append("结构没有匹配到,启动备用方案:将结构当单品处理\n");
					List<PlanProductInfo> templetProductInfoList = templetStructureProudctListMap.get(key);
					if(Lists.isNotEmpty(templetProductInfoList)) {
						List<PlanProductInfo> planProductInfoList = productListByTypeInfo.getProductList();
						for(PlanProductInfo planProductInfo : templetProductInfoList) {
							planProductInfoList.add(planProductInfo);
						}
					}
				}
				this.setSomeInfo(structureMatchInfoDTO, templetStructureProudctListMap.get(key));
				structureMatchInfoDTO.setMatchInfo(matchInfo.toString());
				structureMatchInfoDTOList.add(structureMatchInfoDTO);
			}
		}else {
			// 没有结构需要匹配
		}
		return structureMatchInfoDTOList;
	}
	
	/**
	 * 组合匹配
	 * 
	 * @author huangsongbo
	 * @param templetMainPlanProductInfo 参照组合信息
	 * @param planGroupMainProudctMap 待匹配的组合信息list
	 * @param matchInfo 匹配信息
	 * @return
	 */
	private String groupMatch(PlanProductInfo templetMainPlanProductInfo,
			Map<String, PlanProductInfo> planGroupMainProudctMap, StringBuffer matchInfo) {
		
		// *参数验证 ->start
		if(templetMainPlanProductInfo == null) {
			return null;
		}
		if(planGroupMainProudctMap == null) {
			return null;
		}
		// 区域标识
		String regionMark = templetMainPlanProductInfo.getRegionMark();
		if(StringUtils.isEmpty(regionMark)) {
			matchInfo.append("样板房产品表中,组合的区域标识没有录,只能去匹配组合类型(组合planGroupId:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
		}
		if(templetMainPlanProductInfo.getGroupType() == null) {
			matchInfo.append("组合没有录组合类型!(组合planGroupId:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
			return null;
		}
		// *参数验证 ->end
		
		// 区域标识+组合类型+主产品过滤属性均匹配上的组合
		PlanProductInfo planProductInfoMatchedAll = null;
		
		// 只匹配上组合类型+主产品过滤属性的组合
		PlanProductInfo planProductInfoMatchedType = null;
		
		for(String key : planGroupMainProudctMap.keySet()) {
			// 匹配区域标识+组合类型
			PlanProductInfo planProductInfo = planGroupMainProudctMap.get(key);
			// 匹配组合类型+主产品过滤属性
			if(templetMainPlanProductInfo.getGroupType().intValue() == planProductInfo.getGroupType().intValue()
					&& Utils.isMatched(
							templetMainPlanProductInfo.getProductFilterPropList(), planProductInfo.getProductFilterPropList())
					) {
				if(planProductInfoMatchedType == null) {
					planProductInfoMatchedType = planProductInfo;
				}
				// 再匹配区域标识
				if(!StringUtils.isEmpty(regionMark) && StringUtils.equals(regionMark, planProductInfo.getRegionMark())) {
					planProductInfoMatchedAll = planProductInfo;
				}
			}
		}
		
		if(planProductInfoMatchedAll == null && planProductInfoMatchedType == null) {
			// 去掉过滤属性再匹配一次
			for(String key : planGroupMainProudctMap.keySet()) {
				// 匹配区域标识+组合类型
				PlanProductInfo planProductInfo = planGroupMainProudctMap.get(key);
				// 匹配组合类型+主产品过滤属性
				if(templetMainPlanProductInfo.getGroupType().intValue() == planProductInfo.getGroupType().intValue()) {
					if(planProductInfoMatchedType == null) {
						planProductInfoMatchedType = planProductInfo;
					}
					// 再匹配区域标识
					if(!StringUtils.isEmpty(regionMark) && StringUtils.equals(regionMark, planProductInfo.getRegionMark())) {
						planProductInfoMatchedAll = planProductInfo;
					}
				}
			}
		}
		
		if(planProductInfoMatchedAll != null) {
			matchInfo.append("匹配上了推荐方案中的组合(区域标识+组合类型+主产品过滤属性)!(组合planGroupId:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
			return planProductInfoMatchedAll.getPlanGroupId();
		}else {
			if(planProductInfoMatchedType != null) {
				matchInfo.append("匹配上了推荐方案中的组合(组合类型+主产品过滤属性)!(组合planGroupId:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
				return planProductInfoMatchedType.getPlanGroupId();
			}else {
				// 没有匹配上推荐方案中的组合
				matchInfo.append("没有匹配上推荐方案中的组合(推荐方案中没有相同类型的组合(或者主产品的过滤属性不匹配)(组合类型groupType:" + templetMainPlanProductInfo.getGroupType().intValue() + "))!(组合planGroupId:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
				return null;
			}
		}
	}
	
	private GroupMatchInfoDTO getGroupMatchInfoDTO(
			List<PlanProductInfo> planGroupInfoList,
			String planGroupId, Integer planId, String username, Integer opType) {
		
		// *参数验证 ->start
		if(planGroupInfoList == null) {
			logger.error("function:IntelligenceDecorationServiceImpl.getGroupMatchInfoDTO(....)->\n参数planGroupInfoList = null");
			return null;
		}
		if(StringUtils.isEmpty(planGroupId)) {
			logger.error("function:IntelligenceDecorationServiceImpl.getGroupMatchInfoDTO(....)->\n参数planStructureId:(StringUtils.isEmpty(planGroupId)) = true");
			return null;
		}
		if(planId == null) {
			logger.error("function:IntelligenceDecorationServiceImpl.getGroupMatchInfoDTO(....)->\n参数planStructureId:planId = null");
			return null;
		}
		if(StringUtils.isEmpty(username)) {
			logger.error("function:IntelligenceDecorationServiceImpl.getGroupMatchInfoDTO(....)->\n参数(StringUtils.isEmpty(username)) = true");
			return null;
		}
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		// *参数验证 ->end
		
		GroupMatchInfoDTO groupMatchInfoDTO = new BedroomProductMatchDTO().new GroupMatchInfoDTO();
		List<DetailInfo> groupDetailInfoList = new ArrayList<DetailInfo>();
		
		String newPlanGroupId = null;
		Integer groupOrStructureId = null;
		String flag = Utils.generateRandomDigitString(12);
		if(planGroupId.indexOf("_") != -1) {
			groupOrStructureId = Integer.valueOf(planGroupId.substring(0, planGroupId.indexOf("_")));
			newPlanGroupId = groupOrStructureId + "_" + flag;
		}else {
			throw new RuntimeException("匹配组合成功,生成新的组合plan_group_id失败:没有获取到推荐方案中组合的plan_group_id or plan_group_id格式不正确;");
		}
		
		for(PlanProductInfo planProductInfoItem : planGroupInfoList) {
			PlanProductInfo planProductInfo = planProductInfoItem.clone();
			planProductInfo.setGroupType(0);
			planProductInfo.setGroupOrStructureId(groupOrStructureId);
			planProductInfo.setPlanGroupId(newPlanGroupId);
			Integer designPlanProductId = designPlanProductService.createByPlanProductInfo(planProductInfo, planId, username, opType);
			
			DetailInfo detailInfo = new BedroomProductMatchDTO().new DetailInfo();
			detailInfo.setRecommendedPlanProductCode(planProductInfo.getProductCode());
			detailInfo.setRecommendedPlanProductPosName(planProductInfo.getPosName());
			detailInfo.setDesignPlanProductId(designPlanProductId);
			detailInfo.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			detailInfo.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey());
			detailInfo.setIsMainProduct(planProductInfo.getIsMainProduct());
			detailInfo.setGroupProductUniqueId(planProductInfo.getGroupProductUniqueId());
			detailInfo.setMatchedPosName(planProductInfo.getMatchedPosName());
			groupDetailInfoList.add(detailInfo);
			if(StringUtils.isEmpty(newPlanGroupId)) {
				newPlanGroupId = planProductInfo.getPlanGroupId();
			}
		}
		
		// *结构配置文件路径 ->start
		String groupConfig = null;
		GroupProduct groupProduct = groupProductService.get(groupOrStructureId);
		if(groupProduct == null) {
			throw new RuntimeException("组合未找到,groupId:" + groupOrStructureId);
		}
		Integer configId = Integer.valueOf(groupProduct.getLocation());
		if(configId == null) {
			throw new RuntimeException("组合的配置文件id为空,structureId:" + groupOrStructureId);
		}
		ResFile resFile = resFileService.get(configId);
		if(resFile == null) {
			throw new RuntimeException("配置文件没有找到,resFileId:" + configId);
		}
		/*groupConfig = resFile.getFilePath();*/
		groupConfig=FileUploadUtils.getFileContext(Utils.getAbsolutePath(resFile.getFilePath(), null));
		// *结构配置文件路径 ->end
		
		groupMatchInfoDTO.setGroupDetailInfoList(groupDetailInfoList);
		groupMatchInfoDTO.setNewPlanGroupId(newPlanGroupId);
		groupMatchInfoDTO.setGroupConfig(groupConfig);
		
		return groupMatchInfoDTO;
	}
	
	private void setSameInfo(GroupMatchInfoDTO groupMatchInfoDTO, List<PlanProductInfo> planProductInfoList) {
		
		// 参数验证 ->start
		if(groupMatchInfoDTO == null) {
			groupMatchInfoDTO = new BedroomProductMatchDTO().new GroupMatchInfoDTO();
		}
		if(planProductInfoList == null) {
			return;
		}
		// 参数验证 ->end
		
		List<String> delPosNameList = new ArrayList<String>();
		
		for(PlanProductInfo planProductInfo : planProductInfoList) {
			delPosNameList.add(planProductInfo.getPosName());
		}
		
		groupMatchInfoDTO.setDelPosNameList(delPosNameList);
	}
	
	/**
	 * 保存设计方案产品
	 * 
	 * @author huangsongbo
	 * @param planId 设计方案id
	 * @param username 用户名
	 * @param opType 是否是自动渲染
	 * @param planProductInfo 样板房产品信息
	 * @param matchInfo 匹配信息
	 * @param productMatchInfoDTO 返回信息
	 * @param planProductInfoMatched 匹配上的产品信息
	 */
	private void getProductMatchInfoDTO(Integer planId, String username, Integer opType,
			PlanProductInfo planProductInfo, StringBuffer matchInfo, ProductMatchInfoDTO productMatchInfoDTO,
			PlanProductInfo planProductInfoMatched) {
		Integer designPlanProductId = null;
		if(planProductInfoMatched != null) {
			PlanProductInfo planProductInfoMatchCopy = planProductInfoMatched.clone();
			planProductInfoMatchCopy.setMatched(true);
			planProductInfoMatchCopy.setPlanProductId(planProductInfo.getPlanProductId());
			planProductInfoMatchCopy.setInitProductId(planProductInfo.getInitProductId());
			planProductInfoMatchCopy.setBindParentProductId(planProductInfo.getBindParentProductId());
			planProductInfoMatchCopy.setMeasureCode(planProductInfo.getMeasureCode());
			planProductInfoMatchCopy.setRegionMark(planProductInfo.getRegionMark());
			
			// 有些结构当单品处理了,也要保留结构相关信息 ->start
			planProductInfoMatchCopy.setGroupOrStructureId(planProductInfo.getGroupOrStructureId());
			planProductInfoMatchCopy.setPlanGroupId(planProductInfo.getPlanGroupId());
			planProductInfoMatchCopy.setGroupType(planProductInfo.getGroupType());
			planProductInfoMatchCopy.setIsStandard(planProductInfo.getIsStandard());
			planProductInfoMatchCopy.setCenter(planProductInfo.getCenter());
			// 有些结构当单品处理了,也要保留结构相关信息 ->end
			
			productMatchInfoDTO.setProductCode(planProductInfoMatchCopy.getProductCode());
			productMatchInfoDTO.setBigTypeValuekey(planProductInfoMatchCopy.getBigTypeValuekey());
			productMatchInfoDTO.setSmallTypeValuekey(planProductInfoMatchCopy.getSmallTypeValuekey());
			productMatchInfoDTO.setMatchedPosName(planProductInfoMatchCopy.getMatchedPosName());
			
			designPlanProductId = designPlanProductService.createByPlanProductInfo(planProductInfoMatchCopy, planId, username, opType);
		}else{
			// 如果没有匹配上产品,存原样板房数据 update by huangsongbo 2017.12.26 ->start
			planProductInfo.setIsDeleted(1);
			designPlanProductId = designPlanProductService.createByPlanProductInfo(planProductInfo, planId, username, opType);
			// 如果没有匹配上产品,存原样板房数据 update by huangsongbo 2017.12.26 ->end
		}
		productMatchInfoDTO.setDesignPlanProductId(designPlanProductId);
		productMatchInfoDTO.setMatchInfo(matchInfo.toString());
		// 处理isBJWall参数
		if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM, planProductInfo.getBigTypeValuekey())) {
			if(StringUtils.equals("basic_mengk", planProductInfo.getSmallTypeValuekey())) {
				productMatchInfoDTO.setWallType(WallTypeConstant.MENGKUANG);
			}else {
				productMatchInfoDTO.setWallType(WallTypeConstant.NORMAL);
			}
		}
	}

	/**
	 * 匹配主地面/玄关地面/过道地面(适配户型绘制新逻辑)
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param theSameBigTypePlanProductInfoList
	 * @param recommendedPlanStructureInfo
	 * @param matchInfo
	 * @param dimTypeList 
	 * @return
	 */
	private Map<String, Object> productListMatchDimV2(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, PlanStructureInfo recommendedPlanStructureInfo,
			StringBuffer matchInfo, List<String> dimTypeList) {
		String logSuffix = "function:IntelligenceDecorationServiceImpl.productListMatchDimV2 -> ";
		
		// 参数验证/处理 ->start
		if(planProductInfo == null) {
			logger.error(logSuffix + "planProductInfo = null");
			return null;
		}
		if(recommendedPlanProductInfoList == null) {
			logger.error(logSuffix + "recommendedPlanProductInfoList = null");
			return null;
		}
		// 参数验证/处理 ->end
		
		logger.debug(logSuffix + "posName:" + planProductInfo.getPosName());
		
		Map<String, Object> resultMap = new HashMap<String, Object>();
		PlanProductInfo planProductInfoMatched = null;
		DimMatchInfoVO dimMatchInfoVO = null;
		
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
		
		if(StringUtils.isNotEmpty(planProductInfo.getRegionMark())) {
			// 根据区域标识匹配(相等)
			planProductInfoParam.setSmallTypeValueKeyInitList(dimTypeList);
			planProductInfoParam.setRegionMark(planProductInfo.getRegionMark());
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched != null) {
				// 检查匹配上的地面是不是结构,如果是结构,组装成结构信息返回给前端
				if(StringUtils.isNotEmpty(planProductInfoMatched.getPlanGroupId()) && !StringUtils.equals("0", planProductInfoMatched.getPlanGroupId())) {
					Map<String, List<PlanProductInfo>> structureProudctListMap = recommendedPlanStructureInfo.getStructureProudctListMap();
					dimMatchInfoVO = this.getDimMatchInfoVOByPlanProductInfoList(structureProudctListMap.get(planProductInfoMatched.getPlanGroupId()), planProductInfo.getRegionMark());
				}else {
					dimMatchInfoVO = this.getDimMatchInfoVO(planProductInfo.getRegionMark(), planProductInfoMatched.getRegionMark());
				}
			}
			// 第二轮匹配,备用区域标识匹配
			else {
				planProductInfoMatched = this.structureMatchStandByRegionMark(planProductInfo.getRegionMark(), recommendedPlanProductInfoList);
				if(planProductInfoMatched != null) {
					if(StringUtils.isNotEmpty(planProductInfoMatched.getPlanGroupId()) && !StringUtils.equals("0", planProductInfoMatched.getPlanGroupId())) {
						Map<String, List<PlanProductInfo>> structureProudctListMap = recommendedPlanStructureInfo.getStructureProudctListMap();
						dimMatchInfoVO = this.getDimMatchInfoVOByPlanProductInfoList(structureProudctListMap.get(planProductInfoMatched.getPlanGroupId()), planProductInfo.getRegionMark());
					}else {
						dimMatchInfoVO = this.getDimMatchInfoVO(planProductInfo.getRegionMark(), planProductInfoMatched.getRegionMark());
					}
				}
			}
		}else {
			
		}
		
		if(planProductInfoMatched == null) {
			planProductInfoMatched = this.productListMatchDim(planProductInfo, recommendedPlanProductInfoList, matchInfo);
		}
		
		resultMap.put(IntelligenceDecorationConstant.PRODUCTLISTMATCHDIMRESULTMAP_PLANPRODUCTINFO, planProductInfoMatched);
		resultMap.put(IntelligenceDecorationConstant.PRODUCTLISTMATCHDIMRESULTMAP_DIMMATCHINFOVO, dimMatchInfoVO);
		return resultMap;
	}
	
	/**
	 * 匹配dim类型单品
	 * 匹配不到,可能去系统中搜索
	 * 
	 * @author huangsongbo
	 * @param PlanProductInfoList
	 * @param smallTypeValuekey
	 * @param planProductInfo
	 * @param matchInfo 
	 * @return
	 */
	private PlanProductInfo productListMatchDim(
			PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo
			) {
		
		// *参数验证 ->start
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		if(StringUtils.isEmpty(smallTypeValuekey)) {
			return null;
		}
		if(recommendedPlanProductInfoList == null) {
			return null;
		}
		// *参数验证 ->end
		
		// 地面的话,只要匹配类别基本属性,不需要匹配长宽高等附加属性
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
		if(StringUtils.equals("basic_dimmk", smallTypeValuekey)) {
			
			// *匹配参数设置 ->start
			// 门槛石匹配:样板房的白膜小类与推荐方案的初始化白膜小类
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			// *匹配参数设置 ->end
			
			PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 没有匹配到
				matchInfo.append("门槛石匹配失败(推荐方案中没有门槛石)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
				// 备用方案,去匹配dimz ->start
				// update by huangsongbo 2018.4.2
				matchInfo.append("去匹配dimz\n");
				planProductInfoParam.setSmallTypeValuekeyInit(ProductTypeConstant.PRODUCT_SMALL_TYPE_BASIC_DIMZ);
				planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
				if(planProductInfoMatched == null) {
					matchInfo.append("匹配dimz失败\n");
				}else {
					matchInfo.append("匹配dimz成功\n");
				}
				// 备用方案,去匹配dimz ->end
			}else {
				matchInfo.append("门槛石匹配成功(匹配上了推荐方案中的门槛石)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}
			return planProductInfoMatched;
		}else if(StringUtils.equals("basic_dimct", smallTypeValuekey)) {
			// *匹配参数设置 ->start
			// 窗台石匹配:样板房的白膜小类与推荐方案的初始化白膜小类
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekeyInit());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekeyInit());
			// *匹配参数设置 ->end
			
			// 特殊处理窗台石(小类/备用小类匹配)
			PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 没有匹配到窗台石,就去匹配门槛石
				// *匹配参数设置 ->start
				planProductInfoParam.setSmallTypeValuekeyInit("basic_dimmk");
				// *匹配参数设置 ->end
				
				planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			}else {
				matchInfo.append("窗台石(basic_dimct)匹配成功(匹配上推荐方案中的窗台石))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
				return planProductInfoMatched;
			}
			if(planProductInfoMatched == null) {
				// 没有匹配到
				matchInfo.append("窗台石(basic_dimct)匹配失败(未在推荐方案中找到窗台石/门槛石))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
				
				// update by huangsongbo 2018.4.18 窗台石匹配门槛石失败,就去匹配basic_dim ->start
				matchInfo.append("去匹配basic_dim\n");
				planProductInfoParam.setSmallTypeValuekeyInit("basic_dim");
				planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
				// update by huangsongbo 2018.4.18 窗台石匹配门槛石失败,就去匹配basic_dim ->end
				
				// update by huangsongbo 2018.4.18 窗台石匹配门槛石失败,就去匹配basic_dimz ->start
				if(planProductInfoMatched == null) {
					matchInfo.append("去匹配basic_dimz");
					planProductInfoParam.setSmallTypeValuekeyInit("basic_dimz");
					planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
				}
				// update by huangsongbo 2018.4.18 窗台石匹配门槛石失败,就去匹配basic_dimz ->end
				
			}else {
				matchInfo.append("窗台石(basic_dimct)匹配成功(匹配上推荐方案中的门槛石))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}
			return planProductInfoMatched;
		}
		else {
			// *匹配参数设置 ->start
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			// *匹配参数设置 ->end
			
			PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 没有匹配到
				matchInfo.append("匹配失败(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
				// 主地面备用匹配逻辑
				if(StringUtils.equals("basic_dim", planProductInfoParam.getSmallTypeValuekeyInit())) {
					matchInfo.append("basic_dim再去匹配推荐方案中的basic_dimz\n");
					// 再去匹配"basic_dimz"
					planProductInfoParam.setSmallTypeValuekeyInit("basic_dimz");
					
					planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
					if(planProductInfoMatched == null) {
						// 没有匹配到
						matchInfo.append("匹配失败(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					}else {
						matchInfo.append("匹配成功(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					}
				}
				// 主地面结构中间块地面备用匹配逻辑
				else if(StringUtils.equals("basic_dimz", planProductInfoParam.getSmallTypeValuekeyInit())) {
					matchInfo.append("basic_dimz再去匹配推荐方案中的basic_dim\n");
					// 再去匹配"basic_dimz"
					planProductInfoParam.setSmallTypeValuekeyInit("basic_dim");
					
					planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
					if(planProductInfoMatched == null) {
						// 没有匹配到
						matchInfo.append("匹配失败(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					}else {
						matchInfo.append("匹配成功(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					}
				}
				// 过道地面备用匹配逻辑
				else if(StringUtils.equals("basic_dimgd", planProductInfoParam.getSmallTypeValuekeyInit())) {
					matchInfo.append("basic_dimgd再去匹配推荐方案中的basic_dimz\n");
					// 再去匹配"basic_dimz"
					planProductInfoParam.setSmallTypeValuekeyInit("basic_dimz");
					planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
					if(planProductInfoMatched == null) {
						// 没有匹配到
						matchInfo.append("匹配失败(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
						// 再去匹配basic_dim
						matchInfo.append("basic_dimgd再去匹配推荐方案中的basic_dim\n");
						planProductInfoParam.setSmallTypeValuekeyInit("basic_dim");
						planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
						if(planProductInfoMatched == null) {
							// 没有匹配到
							matchInfo.append("匹配失败(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
						}else {
							matchInfo.append("匹配成功(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
						}
					}else {
						matchInfo.append("匹配成功(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					}
				}
				// 玄关地面备用匹配逻辑
				else if(StringUtils.equals("basic_dimxg", planProductInfoParam.getSmallTypeValuekeyInit())) {
					matchInfo.append("basic_dimxg再去匹配推荐方案中的basic_dimz\n");
					// 再去匹配"basic_dimz"
					planProductInfoParam.setSmallTypeValuekeyInit("basic_dimz");
					planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
					if(planProductInfoMatched == null) {
						// 没有匹配到
						matchInfo.append("匹配失败(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
						// 再去匹配basic_dim
						matchInfo.append("basic_dimgd再去匹配推荐方案中的basic_dim\n");
						planProductInfoParam.setSmallTypeValuekeyInit("basic_dim");
						planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
						if(planProductInfoMatched == null) {
							// 没有匹配到
							matchInfo.append("匹配失败(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
						}else {
							matchInfo.append("匹配成功(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
						}
					}else {
						matchInfo.append("匹配成功(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					}
				}
				// 阳台地面备用匹配逻辑(阳台地面>主地面>结构主地面)
				else if(StringUtils.equals("basic_dimyt", planProductInfoParam.getSmallTypeValuekeyInit())) {
					matchInfo.append("阳台地面匹配备用小类:主地面(dim)\n");
					planProductInfoParam.setSmallTypeValuekeyInit("basic_dim");
					planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
					if(planProductInfoMatched == null) {
						matchInfo.append("匹配失败\n");
						matchInfo.append("阳台地面匹配备用小类:结构主地面(dimz)\n");
						planProductInfoParam.setSmallTypeValuekeyInit("basic_dimz");
						planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
						if(planProductInfoMatched == null) {
							matchInfo.append("匹配失败\n");
						}else {
							matchInfo.append("匹配成功\n");
						}
					}else {
						matchInfo.append("匹配成功\n");
					}
				}
			}else {
				matchInfo.append("匹配成功(按产品的初始化白膜大小类匹配))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}
			
			return planProductInfoMatched;
		}
	}
	
	/**
	 * 匹配门
	 * @param planProductInfo
	 * @param matchInfo 
	 * @param theSameBigTypePlanProductInfoList
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private PlanProductInfo productListMatchMeng(
			PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo
			) {
		String logPrefix = "function:IntelligenceDecorationServiceImpl.productListMatchMeng -> ";
		
		logger.debug(logPrefix + "posName:" + planProductInfo.getPosName() + "\n");
		
		// 设置匹配条件(附加属性,产品长,产品高)
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
		planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
		
		// 所有recommendedPlanProductInfoList加上过滤属性信息为了匹配 ->start
		recommendedPlanProductInfoList.forEach(recommendedPlanProductInfo -> {
			recommendedPlanProductInfo.setProductFilterPropList(baseProductService.getProductFilterPropList(recommendedPlanProductInfo.getProductId()));
		});
		// 所有recommendedPlanProductInfoList加上过滤属性信息为了匹配 ->end
		
		// update by huangsongbo 2018.4.25 门匹配加入过滤属性匹配 ->start
		List<ProductPropsSimple> productFilterPropList = baseProductService.getProductFilterPropList(planProductInfo.getProductId());
		planProductInfoParam.setProductFilterPropList(productFilterPropList);
		// update by huangsongbo 2018.4.25 门匹配加入过滤属性匹配 ->end
		
		Map<String,String > stretchZoomMap = baseProductService.getStretchZoomLength(planProductInfoParam.getSmallTypeValuekey());
		if(stretchZoomMap != null && stretchZoomMap.get(ProductModelConstant.STRETCH_LENGTH) != null) {
			int stretchLength = Utils.getIntValue(stretchZoomMap.get(ProductModelConstant.STRETCH_LENGTH));
			this.setBeijingMatchParams(planProductInfo, planProductInfoParam, stretchLength);
			if(stretchZoomMap.get(ProductModelConstant.IS_HEIGHT_FILTER) != null 
					&& StringUtils.equals("yes", stretchZoomMap.get(ProductModelConstant.IS_HEIGHT_FILTER))) {
				planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
			}
		}else {
			planProductInfoParam.setProductLength(planProductInfo.getProductLength());
			planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
		}
		
		matchInfo.append("门小类+过滤属性+门长高 匹配\n");
		PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
		
		if(planProductInfoMatched == null) {
			matchInfo.append("匹配失败,再次匹配(门小类+过滤属性)\n");
			// 门小类+过滤属性+门长高 匹配失败,去掉 门长高 匹配条件再匹配一次 add by huangsongbo 2018.4.25
			planProductInfoParam.setProductLength(null);
			planProductInfoParam.setProductLengthStart(null);
			planProductInfoParam.setProductLengthEnd(null);
			planProductInfoParam.setProductHeight(null);
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
		}else {
			matchInfo.append("匹配成功,直接应用该产品\n");
			return planProductInfoMatched;
		}
		
		if(planProductInfoMatched == null) {
			matchInfo.append("匹配失败,再次匹配(门小类)\n");
			// 小类+属性匹配失败,去掉属性匹配条件再匹配一次 add by huangsongbo 2018.4.25
			planProductInfoParam.setProductFilterPropList(null);
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
		}else {
			matchInfo.append("匹配成功(recommendedProductCode = " + planProductInfoMatched.getProductCode() + ")\n");
		}
		
		if(planProductInfoMatched == null) {
			matchInfo.append("匹配失败,准备在系统中自行搜索\n");
		}else {
			matchInfo.append("根据匹配到的门的条件+自身白膜门的条件,在系统中自行搜索\n");
		}
		
		// 自行搜索 ->start
		try{
			planProductInfoParam.setOrderAbsProuductLength(Integer.parseInt(planProductInfo.getProductLength()));
		}catch(Exception e){
			logger.error(e.toString());
			logger.error("全铺长度值有问题:baseProductCode = " + planProductInfo.getProductCode() + ";fullPaveLength = " + planProductInfo.getFullPaveLength());
		}
		
		// 添加搜索条件:门小类互搜(优先本小类),门的过滤属性 add by huangsongbo 2018.4.25 ->start
		planProductInfoParam.setSmallTypeValuekey(null);
		Map<getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum, Object> smallTypeListProperties = baseProductService.getSmallTypeValueListBySmallTypeValueKey(planProductInfo.getSmallTypeValuekey());
		if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in)) {
			planProductInfoParam.setSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in));
			planProductInfoParam.setSmallTypeValueKeyList((List<String>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.inKey));
		}else {
			if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn)) {
				planProductInfoParam.setExcludeSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn));
			}
		}
		planProductInfoParam.setOrderSmallTypeValueKey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
		planProductInfoParam.setProductFilterPropList(productFilterPropList);
		// 添加搜索条件:门小类互搜(优先本小类),门的过滤属性 add by huangsongbo 2018.4.25 ->end
		
		// 如果匹配到门,设置一些匹配到的门的信息 ->start
		if(planProductInfoMatched != null) {
			planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
			planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
		}
		// 如果匹配到门,设置一些匹配到的门的信息 ->end
		
		planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
		if(planProductInfoMatched == null) {
			matchInfo.append("未搜索到产品");
		}else {
			matchInfo.append("在系统中搜索到产品");
		}
		// 自行搜索 ->end
		
		return planProductInfoMatched;
	}
	
	/**
	 * 匹配墙面(除了背景墙)
	 * @param planProductInfo
	 * @param recommendedPlanProductInfoList
	 * @param matchInfo 
	 * @return
	 */
	private PlanProductInfo productListMatchQiangm(
			PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo
			) {
		
		// *参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return null;
		}
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		if(StringUtils.isEmpty(smallTypeValuekey)) {
			return null;
		}
		// *参数验证 ->end
		
		// 匹配条件
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		
		if(StringUtils.equals("basic_mengk", smallTypeValuekey)) {
			// 特殊处理门框匹配
			matchInfo.append("正在匹配门框\n");
			
			// 设置匹配条件 ->start
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
			
			// update by huangsongbo 2018.6.4 门框匹配规则修改,匹配+-10cm门框 ->start
			/*planProductInfoParam.setProductLength(planProductInfo.getProductLength());*/
			Integer productLength = null;
			if(StringUtils.isNotEmpty(planProductInfo.getProductLength())) {
				try {
					productLength = Integer.valueOf(planProductInfo.getFullPaveLength());
				} catch (Exception e) {
					logger.error("String转化Integer失败:planProductInfo.getProductLength() = " + planProductInfo.getProductLength() + ";Exception = " + e.toString());
				}
				if(productLength != null) {
					planProductInfoParam.setProductLengthStart(productLength - 10);
					planProductInfoParam.setProductLengthEnd(productLength + 10);
				}
			}
			// update by huangsongbo 2018.6.4 门框匹配规则修改,匹配+-10cm门框 ->start
			
			// 设置匹配条件 ->end
			
			PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			
			if(planProductInfoMatched == null) {
				// 没有匹配到
				matchInfo.append("匹配失败,自行搜索\n");
				planProductInfoParam.setProductLengthStart(null);
				planProductInfoParam.setProductLengthEnd(null);
				if(productLength != null) {
					planProductInfoParam.setOrderAbsProuductLength(productLength);
				}
				planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
			}else {
				matchInfo.append("匹配成功,直接应用此门框\n");
			}
			return planProductInfoMatched;
		}else if(StringUtils.equals("basic_chuangk", smallTypeValuekey)) {
			matchInfo.append("正在匹配窗框(大小类,长高)\n");
			
			// 特殊处理门框/窗框(小类/长高)
			// 设置匹配条件(附加属性,产品长,产品高)
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			planProductInfoParam.setProductLength(planProductInfo.getProductLength());
			planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
			
			PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			
			if(planProductInfoMatched == null) {
				matchInfo.append("匹配失败,去掉长高匹配条件再次匹配\n");
				planProductInfoParam.setProductLength(null);
				planProductInfoParam.setProductHeight(null);
				planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			}else {
				matchInfo.append("匹配成功,直接应用此产品\n");
				return planProductInfoMatched;
			}
			
			if(planProductInfoMatched == null) {
				// 没有匹配到
				matchInfo.append("匹配失败,删除门框.窗框\n");
			}else {
				matchInfo.append("大小类匹配成功,然后验证窗框的长高\n");
				planProductInfoParam.setProductLength(planProductInfo.getProductLength());
				planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
				if(this.productMatchCheckMoreInfo(planProductInfoMatched, planProductInfoParam)) {
					matchInfo.append("窗框的长高也匹配成功,应用此产品(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
				}else {
					// 自行搜索
					planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
					if(planProductInfoMatched == null) {
						/*planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
						planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));*/
						matchInfo.append("在系统中也没有搜索到产品,"
								+ "搜索条件:bigTypeValuekey:" + planProductInfoParam.getBigTypeValuekey() + ";smallTypeValuekey:" + planProductInfoParam.getSmallTypeValuekey()
								+ ";productLength:" + planProductInfoParam.getProductLength() + ";productHeight:" + planProductInfoParam.getProductHeight()
								+ "(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					}else {
						matchInfo.append("在系统中搜索到产品");
					}
				}
			}
			return planProductInfoMatched;
		}else {
			// 设置匹配条件
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			
			PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 没有匹配到
				matchInfo.append("匹配失败(按初始化白膜大小类)(" + planProductInfo.getSmallTypeValuekeyInit() + "))(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}else {
				matchInfo.append("匹配成功(按初始化白膜大小类)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}
			return planProductInfoMatched;
		}
	}
	
	/**
	 * 匹配天花,户型绘制功能上线之后,天花都由前端生成,因对此情况而改造的逻辑
	 * 一件装修之后,如果推荐方案是老数据,只要存匹配上的天花的id,进入设计方案后,会根据天花的款式+顶点信息+天花截面信息,自动生成一个新的天花
	 * 一件装修之后,如果推荐方案是新数据,也只要应用匹配上的天花的id就可以
	 * 
	 * @param planProductInfo
	 * @param recommendedPlanProductInfoList
	 * @param matchInfo 
	 * @param smallpoxIdentify
	 * @return
	 * @throws IntelligenceDecorationException 
	 */
	private PlanProductInfo productListMatchTianhForDrawHouse(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo, String smallpoxIdentify) throws IntelligenceDecorationException {
		
		// *参数验证 ->start
		if(matchInfo == null) {
			return null;
		}
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		if(StringUtils.isEmpty(smallTypeValuekey)) {
			return null;
		}
		if(recommendedPlanProductInfoList == null) {
			return null;
		}
		// *参数验证 ->end
		
		// *设置匹配参数 ->start
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		
		PlanProductInfo planProductInfoMatched = null;
				
		planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
		if(StringUtils.isEmpty(planProductInfo.getRegionMark())) {
			throw new IntelligenceDecorationException("检测到该样板房天花没有录区域标识");
		}
		// *设置匹配参数 ->end
		
		planProductInfoParam.setRegionMark(planProductInfo.getRegionMark());
		planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
		
		// 区域标识匹配
		if(planProductInfoMatched != null) {
			return planProductInfoMatched;
		}else {
			// 区域标识没有匹配上->匹配备用的区域标识(过道匹配其他过道,没有过道匹配主天花)
			// 主天花的区域编码是1开头(10,11),过道优先匹配其他过道,再玄关,再主天花
			// 玄关优先匹配玄关,再过道,再主天花
			// 例如过道的区域标识是21,则推荐方案中区域标识2开头的天花
			planProductInfoParam.setRegionMark(null);
			planProductInfoParam.setRegionMarkLikeStart(planProductInfo.getRegionMark().substring(0, 1));
			// 优先匹配同类型天花(过道匹配过道,玄关匹配玄关)
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 如果是主天花没有匹配上,不应该出现这种情况(因为推荐方案肯定会有一个主天花)
				if(planProductInfo.getRegionMark().startsWith("1")) {
					matchInfo.append("主天花都没有匹配上,检查推荐方案的主天花是否录了区域标识,准备自行搜索天花(regionMark)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					throw new IntelligenceDecorationException("推荐方案中未识别到主天花(主天花区域标识没录或者录错)");
				}else {
					// 匹配区域标识非1开头的天花(eg:过道天花匹配不到过道天花后,优先匹配玄关天花)
					planProductInfoParam.setRegionMarkLikeStart(null);
					planProductInfoParam.setRegionMarkNotLikeStart("1");
					planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
					if(planProductInfoMatched == null) {
						// 匹配主天花
						planProductInfoParam.setRegionMarkNotLikeStart(null);
						planProductInfoParam.setRegionMarkLikeStart("1");
						planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
						if(planProductInfoMatched == null) {
							matchInfo.append("推荐方案没有发现主天花,请检查推荐方案主天花的区域标识(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
							throw new IntelligenceDecorationException("推荐方案中未识别到主天花(主天花区域标识没录或者录错)");
						}else {
							matchInfo.append("非主天花匹配到推荐方案的主天花,带款式+尺寸编码搜索系统中的天花(regionMark)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
							return planProductInfoMatched;
						}
					}else {
						return planProductInfoMatched;
					}
				}
			}else {
				return planProductInfoMatched;
			}
		}
	}
	
	/**
	 * 家纺匹配(主要是窗帘要匹配长高)
	 * @param planProductInfo
	 * @param recommendedPlanProductInfoList
	 * @param matchInfo
	 * @return
	 */
	private PlanProductInfo productListMatchHo(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo) {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return null;
		}
		// 参数验证 ->end
		
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		PlanProductInfo planProductInfoMatched = null;
		
		logger.debug("posName:" + planProductInfo.getPosName());
		
		// 窗帘/定制窗帘
		if(StringUtils.equals("basic_cuho", smallTypeValuekey) || StringUtils.equals("basic_dzho", smallTypeValuekey)) {
			matchInfo.append("识别为窗帘/定制窗帘\n");
			matchInfo.append("匹配条件:大小类+长高+过滤属性");
			
			// 设置匹配条件(附加属性,产品长,产品高) ->start
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekeyInit());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekeyInit());
			// 设置匹配条件(附加属性,产品长,产品高) ->end
			
			// update by huangsongbo 2018.4.27 ->start
			planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
			
			Map<String,String> stretchMap = baseProductService.getStretchZoomLength(smallTypeValuekey);
			if (stretchMap != null && stretchMap.size() > 0) {
				int stretchLength = Utils.getIntValue(stretchMap.get(ProductModelConstant.STRETCH_LENGTH));
				this.setBeijingMatchParams(planProductInfo, planProductInfoParam, stretchLength);
			} else {
				
			}
			
			/*this.setBeijingMatchParams(planProductInfo, planProductInfoParam, null);*/
			planProductInfoParam.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
			// update by huangsongbo 2018.4.27 ->end
			
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			
			if(planProductInfoMatched == null) {
				matchInfo.append("匹配失败,带匹配条件:大小类,再次匹配\n");
				planProductInfoParam.setProductFilterPropList(null);
				planProductInfoParam.setProductHeight(null);
				planProductInfoParam.setProductLength(null);
				planProductInfoParam.setProductLengthEnd(null);
				planProductInfoParam.setProductLengthStart(null);
				planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			}else {
				matchInfo.append("匹配成功,直接应用\n");
				return planProductInfoMatched;
			}
			
			if(planProductInfoMatched == null) {
				// 没有匹配到(说明没有窗帘)
				matchInfo.append("匹配失败\n");
			}else {
				matchInfo.append("匹配成功,matchProductCode: = " + planProductInfoMatched.getProductCode() + ";带该产品的款式和型号去系统中搜索\n");
				matchInfo.append("匹配失败,准备去系统中搜索\n");
				// 长宽不匹配,准备带款式去系统中搜素
				planProductInfoParam.setBigTypeValuekeyInit(null);
				planProductInfoParam.setSmallTypeValuekeyInit(null);
				planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
				planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
				planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
				planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
				planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
				this.setBeijingMatchParams(planProductInfo, planProductInfoParam, null);
				planProductInfoParam.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
				String splitTexturesInfoRecommended = planProductInfoMatched.getSplitTexturesChooseInfo();
				Integer productIdRecommended = planProductInfoMatched.getProductId();
				planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
				if(planProductInfoMatched == null) {
					matchInfo.append("在系统中也没有搜索到产品\n");
				}else {
					String splitTexturesInfo = designPlanProductService.matchSplitTexturesInfo(planProductInfoMatched.getSplitTexturesChooseInfo(), productIdRecommended, splitTexturesInfoRecommended);
					planProductInfoMatched.setSplitTexturesChooseInfo(splitTexturesInfo);
					matchInfo.append("在系统中搜索到产品");
				}
			}
		}else {
			// 其他小类
			planProductInfoMatched = productListMatchOther(planProductInfo, recommendedPlanProductInfoList, matchInfo);
		}
		
		return planProductInfoMatched;
	}
	
	/**
	 * 匹配柜子
	 * 
	 * @author huangsongbo
	 * @param planProductInfo 样板房柜子白膜信息
	 * @param recommendedPlanProductInfoList 推荐方案中所有柜子类产品信息
	 * @param matchInfo
	 * @return
	 */
	private PlanProductInfo productListMatchCa(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo) {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return null;
		}
		// 参数验证 ->end
		
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		PlanProductInfo planProductInfoMatched = null;
		// basic_waca,basic_dyca 衣柜/定制衣柜
		if(StringUtils.equals("basic_waca", smallTypeValuekey) || StringUtils.equals("basic_dyca", smallTypeValuekey)) {
			matchInfo.append("识别为衣柜(匹配条件加上过滤属性(朝向))\n");
			
			// *匹配参数设置 ->start
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			// *匹配参数设置 ->end
			
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 没有匹配到,搜索单品
				matchInfo.append("匹配失败(初始化白膜大小类)\n");
			}else {
				matchInfo.append("匹配成功(按初始化白膜大小类)(匹配到:" + planProductInfoMatched.getProductCode() + "),准备匹配过滤属性\n");
				
				// 获取过滤属性 ->start
				planProductInfo.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
				planProductInfoMatched.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfoMatched.getProductId()));
				// 获取过滤属性 ->end
			
				if(Utils.isMatched(planProductInfo.getProductFilterPropList(), planProductInfoMatched.getProductFilterPropList())){
					// 属性匹配成功,直接用推荐方案中的该产品
					matchInfo.append("属性匹配成功\n");
				}else {
					// 自行搜索
					matchInfo.append("属性匹配失败,带上推荐方案的衣柜的款式去系统中搜索\n");
					planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
					planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfoMatched.getSmallTypeValuekey()));
					planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
					planProductInfoParam.setProductFilterPropList(planProductInfo.getProductFilterPropList());
					planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
					/*selectOneProduct方法增加过滤属性搜索条件*/
				}
			}
			return planProductInfoMatched;
		}else {
			// 其他小类
			planProductInfoMatched = this.productListMatchOther(planProductInfo, recommendedPlanProductInfoList, matchInfo);
		}
		
		return planProductInfoMatched;
	}
	
	/**
	 * 匹配卫浴
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param theSameBigTypePlanProductInfoList
	 * @param matchInfo
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private PlanProductInfo productListMatchBa(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo) {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return null;
		}
		// 参数验证 ->end
		logger.debug("posName:" + planProductInfo.getPosName());
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		PlanProductInfo planProductInfoMatched = null;
		// basic_waca,basic_dyca 衣柜/定制衣柜
		if(StringUtils.equals("basic_asba", smallTypeValuekey)) {
			matchInfo.append("识别为淋浴房(弧形,砖石型..)\n");
			// 根据类别匹配
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValueKeyList(Arrays.asList(new String[] {"ahba", "asba"}));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				matchInfo.append("没有匹配到对应产品(大小类)\n");
			}else {
				matchInfo.append("匹配到对应产品(大小类),准备匹配产品的过滤属性\n");
				// 获取过滤属性 ->start
				planProductInfo.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
				planProductInfoMatched.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfoMatched.getProductId()));
				// 获取过滤属性 ->end
				if(Utils.isMatched(planProductInfo.getProductFilterPropList(), planProductInfoMatched.getProductFilterPropList())){
					matchInfo.append("属性匹配成功,应用此产品\n");
				}else {
					matchInfo.append("属性匹配失败,准备自行搜索(过滤属性+型号+品牌)\n");
					planProductInfoParam.setProductFilterPropList(planProductInfo.getProductFilterPropList());
					planProductInfoMatched = this.selectOneProductBa(planProductInfo, planProductInfoMatched, planProductInfoParam);
				}
			}
		}else if(StringUtils.equals("basic_ahba", smallTypeValuekey)) {
			matchInfo.append("识别为一字型淋浴房\n");
			// 检测推荐方案有没有淋浴房
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			/*planProductInfo.setSmallTypeValueKeyList(Arrays.asList(new String[] {"ahba", "asba"}));*/
			planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 删除样板房中的白膜
				matchInfo.append("没有匹配到对应产品(小类:一字型淋浴房),准备去匹配淋浴房\n");
				planProductInfoParam.setSmallTypeValuekey("asba");
				planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
				if(planProductInfoMatched == null) {
					matchInfo.append("淋浴房也没有匹配上,删除白膜");
				}else {
					matchInfo.append("一字型淋浴房匹配上淋浴房,带淋浴房的型号+品牌+本身的全铺长度去系统中搜索");
					this.setBeijingMatchParams(planProductInfo, planProductInfoParam, null);
					planProductInfoMatched = selectOneProductBa(planProductInfo, planProductInfoMatched, planProductInfoParam);
				}
			}else {
				// 匹配全铺长度
				matchInfo.append("匹配到对应产品(大小类),准备匹配全铺长度\n");
				this.setBeijingMatchParams(planProductInfoMatched, planProductInfoParam, null);
				if(this.productMatchCheckMoreInfo(planProductInfoMatched, planProductInfoParam)) {
					matchInfo.append("匹配全铺长度成功,应用此产品\n");
				}else {
					// 带型号+品牌去系统中搜索
					matchInfo.append("全铺长度匹配失败,自行搜索(型号+品牌+全铺长度)\n");
					planProductInfoMatched = selectOneProductBa(planProductInfo, planProductInfoMatched, planProductInfoParam);
				}
			}
		}else if(StringUtils.equals("basic_baba", smallTypeValuekey) || StringUtils.equals("basic_edba", smallTypeValuekey)) {
			// 浴缸匹配
			matchInfo.append("识别为浴缸\n");
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValueKeyList(Arrays.asList(new String[] {"baba", "edba"}));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				// 推荐方案中没有浴缸,样板房删除浴缸
				matchInfo.append("匹配失败,推荐方案中没有浴缸\n");
				// 2017.12.5修改为,推荐方案中没有浴缸,也要自行搜索一个浴缸 create by huangsongbo ->start
				/*planProductInfoParam.setSmallTypeValueKeyList(null);
				planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));
				planProductInfoMatched = this.selectOneProduct(planProductInfoParam);*/
				// 2017.12.5修改为,推荐方案中没有浴缸,也要自行搜索一个浴缸 create by huangsongbo ->end
			}else {
				// 推荐方案中有浴缸
				matchInfo.append("匹配成功,验证是否为同种类浴缸(嵌入式/独立式)\n");
				planProductInfo.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
				planProductInfoMatched.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfoMatched.getProductId()));
				if(StringUtils.equals(planProductInfo.getSmallTypeValuekey().replace("basic_", ""), planProductInfoMatched.getSmallTypeValuekey())
						&& Utils.isMatched(planProductInfo.getProductFilterPropList(), planProductInfoMatched.getProductFilterPropList())
						) {
					matchInfo.append("验证为同种类浴缸,且过滤属性相同,应用此产品");
				}else {
					matchInfo.append("验证为不同种类浴缸,带型号+品牌去系统中搜素");
					planProductInfoParam.setSmallTypeValueKeyList(null);
					planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));
					planProductInfoParam.setOrderBrandId(planProductInfoMatched.getBrandId());
					planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
					planProductInfoParam.setProductFilterPropList(planProductInfo.getProductFilterPropList());
					planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
				}
			}
		}else if(StringUtils.equals("basic_haba", smallTypeValuekey)) {
			// 匹配花洒(添加过滤属性匹配)(basic_haba)

			// *匹配参数设置 ->start
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			planProductInfoParam.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
			// *匹配参数设置 ->end
			
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				matchInfo.append("匹配失败(按初始化白膜的大小类匹配),删除样板房白膜(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}else {
				matchInfo.append("匹配成功(按初始化白膜的大小类匹配)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}
		
		}
		// 浴室柜/定制浴室柜 add by huangsongbo 2018.1.4
		else if(
				StringUtils.equals("basic_btba", smallTypeValuekey) || StringUtils.equals("basic_dyba", smallTypeValuekey)
				|| StringUtils.equals("basic_dzmiba", smallTypeValuekey)
				) {
			matchInfo.append("识别为浴室柜/定制浴室柜\n");
			
			// 匹配参数设置 ->start
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getBigTypeValuekey()));
			// 备注:现在的配置是:浴室柜白膜能搜浴室柜,定制浴室柜白膜能搜定制浴室柜+浴室柜
			Map<getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum, Object> smallTypeListProperties = baseProductService.getSmallTypeValueListBySmallTypeValueKey(planProductInfo.getSmallTypeValuekey());
			if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in)) {
				planProductInfoParam.setSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in));
				planProductInfoParam.setSmallTypeValueKeyList((List<String>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.inKey));
			}else {
				if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn)) {
					planProductInfoParam.setExcludeSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn));
				}
			}
			// 匹配参数设置 ->end
			
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null){
				// 推荐方案中没有同类别产品,删除样板房该白膜
				matchInfo.append("匹配失败,没有找到同类型的产品\n");
			}else{
				// 检测到有同类型产品,校验长度是否符合
				Map<String,String> stretchMap = baseProductService.getStretchZoomLength(planProductInfo.getSmallTypeValuekey());
				if (stretchMap != null && stretchMap.size() > 0) {
					int stretchLength = Utils.getIntValue(stretchMap.get(ProductModelConstant.STRETCH_LENGTH));
					this.setBeijingMatchParams(planProductInfo, planProductInfoParam, stretchLength);
				}
				// 是定制浴室柜的话,长度要符合,如果是普通的浴室柜,不需要考虑长度 update by huangsongbo 2018.1.15
				if(this.productMatchCheckMoreInfo(planProductInfoMatched, planProductInfoParam) || StringUtils.equals(ProductTypeConstant.PRODUCT_SMALL_TYPE_BTBA, planProductInfoMatched.getSmallTypeValuekey())){
					matchInfo.append("长度也匹配成功,应用此产品\n");
				}else{
					// 自行搜索,并且去长度差绝对值最小的
					matchInfo.append("长度匹配失败,自行搜索\n");
					planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
					planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
					planProductInfoParam.setOrderSmallTypeValueKey(planProductInfoMatched.getSmallTypeValuekey());
					try{
						planProductInfoParam.setOrderAbsProuductLength(Integer.parseInt(planProductInfo.getFullPaveLength()));
					}catch(Exception e){
						logger.error(e.toString());
						logger.error("全铺长度值有问题:baseProductCode = " + planProductInfo.getProductCode() + ";fullPaveLength = " + planProductInfo.getFullPaveLength());
					}
					planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
					if(planProductInfoMatched == null) {
						matchInfo.append("没有搜索到符合条件的产品,去掉长度查询条件搜索浴室柜\n");
						// 就只搜浴室柜,并且去掉长度的限制
						planProductInfoParam.setSmallTypeValueKeyList(null);
						planProductInfoParam.setSmallTypeValueList(null);
						planProductInfoParam.setProductLengthStart(null);
						planProductInfoParam.setProductLengthEnd(null);
						if(StringUtils.equals("basic_btba", smallTypeValuekey) || StringUtils.equals("basic_dyba", smallTypeValuekey)) {
							planProductInfoParam.setSmallTypeValuekey(ProductTypeConstant.PRODUCT_SMALL_TYPE_BTBA);
						}else {
							planProductInfoParam.setSmallTypeValuekey(ProductTypeConstant.PRODUCT_SMALL_TYPE_CABA);
						}
						planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
						if(planProductInfoMatched == null) {
							matchInfo.append("搜索失败\n");
						}
					}else{
						matchInfo.append("自行搜索success\n");
					}
				}
			}
		}
		
		// basic_caba add by huangsongbo 2018.5.16 ->start
		else if(StringUtils.equals("basic_caba", smallTypeValuekey)) {
			
			// 匹配同小类 ->start
			matchInfo.append("识别为basic_caba(原镜柜),匹配同小类\n");
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getBigTypeValuekey()));
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(smallTypeValuekey));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched != null) {
				matchInfo.append("匹配success\n");
				return planProductInfoMatched;
			}else {
				matchInfo.append("匹配failed\n");
			}
			// 匹配同小类 ->end
			
			// 匹配多小类 ->start
			matchInfo.append("匹配多个小类(miba,dzmiba,caba)\n");
			Map<getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum, Object> smallTypeListProperties = baseProductService.getSmallTypeValueListBySmallTypeValueKey(planProductInfo.getSmallTypeValuekey());
			planProductInfoParam.setSmallTypeValueKeyList((List<String>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.inKey));
			if(Lists.isEmpty(planProductInfoParam.getSmallTypeValueKeyList())) {
				// 配置出现问题
				logger.error("error:app.properties:product.searchProduct.showMoreSmallType配置出现问题,miba,dzmiba,caba三个小类应该能够互搜");
				matchInfo.append("配置出现问题,miba,dzmiba,caba三个小类应该能够互搜\n");
				return planProductInfoMatched;
			}
			planProductInfoParam.setSmallTypeValuekey(null);
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched != null) {
				// 如果匹配到的是dzmiba,则要满足长度+-5
				if(StringUtils.equals(ProductTypeConstant.PRODUCT_SMALL_TYPE_DZMIBA, planProductInfoMatched.getSmallTypeValuekey())) {
					matchInfo.append("匹配到了dzmiba(定制浴室柜),我需要再验证一个条件:满足长度+-5\n");
					Integer designTempletProductProductLength = 0;
					if(StringUtils.isNotEmpty(planProductInfo.getFullPaveLength())) {
						try {
							designTempletProductProductLength = Integer.valueOf(planProductInfo.getFullPaveLength());
						}catch (Exception e) {
							
						}
					}else {
						if(StringUtils.isNotEmpty(planProductInfo.getProductLength())) {
							try {
								designTempletProductProductLength = Integer.valueOf(planProductInfo.getProductLength());
							}catch (Exception e) {
								
							}
						}
					}
					planProductInfoParam.setProductLengthStart(designTempletProductProductLength - 5);
					planProductInfoParam.setProductLengthEnd(designTempletProductProductLength + 5);
					if(this.productMatchCheckMoreInfo(planProductInfoMatched, planProductInfoParam)) {
						matchInfo.append("产品长度也符合条件,应用此产品\n");
					}else {
						matchInfo.append("产品长度不符合条件,自行搜索\n");
						matchInfo.append("搜索有没有符合条件的dzmiba(需要带产品长度限制条件)\n");
						List<String> smallTypeValueKeyList = planProductInfoParam.getSmallTypeValueKeyList();
						planProductInfoParam.setSmallTypeValuekey(planProductInfoMatched.getSmallTypeValuekey());
						planProductInfoParam.setSmallTypeValueKeyList(null);
						// add by huangsongbo 2018.5.23
						planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
						planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
						// add by huangsongbo 2018.5.23
						planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
						if(planProductInfoMatched == null) {
							matchInfo.append("搜索 failed\n");
							matchInfo.append("搜索miba/caba,并且取长度最接近的产品\n");
							smallTypeValueKeyList.remove(ProductTypeConstant.PRODUCT_SMALL_TYPE_DZMIBA);
							planProductInfoParam.setSmallTypeValueKeyList(smallTypeValueKeyList);
							planProductInfoParam.setProductLengthEnd(null);
							planProductInfoParam.setProductLengthStart(null);
							planProductInfoParam.setSmallTypeValuekey(null);
							planProductInfoParam.setOrderAbsProuductLength(designTempletProductProductLength);
							planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
							if(planProductInfoMatched == null) {
								matchInfo.append("搜索 failed,删除白膜\n");
							}else {
								matchInfo.append("搜索 success\n");
							}
						}else {
							matchInfo.append("搜索 success\n");
						}
					}
				}else {
					matchInfo.append("匹配到miba or caba,直接应用");
				}
			}else {
				matchInfo.append("匹配failed,删除此白膜\n");
			}
			// 匹配多小类 ->end
			
		}
		// basic_caba add by huangsongbo 2018.5.16 ->end
		
		// 面盆 add by huangsongbo 2018.1.18 ->start
		else if(StringUtils.equals("basic_mpba", smallTypeValuekey)){
			matchInfo.append("识别为面盆,按大小类匹配");
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			/*planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));*/
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				matchInfo.append("大小类匹配失败");
			}else{
				matchInfo.append("大小类匹配成功");
			}
		}
		// 面盆 add by huangsongbo 2018.1.18 ->end
		// 其他小类
		else {
			planProductInfoMatched = productListMatchOther(planProductInfo, recommendedPlanProductInfoList, matchInfo);
		}
		
		return planProductInfoMatched;
	}
	
	private PlanProductInfo productListMatchKp(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo) {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return null;
		}
		// 参数验证 ->end
		logger.debug("posName:" + planProductInfo.getPosName());
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		PlanProductInfo planProductInfoMatched = null;
		if(StringUtils.equals("basic_sikp", smallTypeValuekey)) {
			// 匹配水槽(添加过滤属性匹配)(basic_sikp)

			// *匹配参数设置 ->start
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));
			/*planProductInfoParam.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));*/
			// *匹配参数设置 ->end
			
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				matchInfo.append("匹配失败(按初始化白膜的大小类匹配),删除样板房白膜(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
			}else {
				// 匹配产品属性
				matchInfo.append("匹配成功(按初始化白膜大小类)(匹配到:" + planProductInfoMatched.getProductCode() + "),准备匹配过滤属性\n");
				
				// 获取过滤属性 ->start
				planProductInfo.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
				planProductInfoMatched.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfoMatched.getProductId()));
				// 获取过滤属性 ->end
			
				if(Utils.isMatched(planProductInfo.getProductFilterPropList(), planProductInfoMatched.getProductFilterPropList())){
					// 属性匹配成功,直接用推荐方案中的该产品
					matchInfo.append("属性匹配成功\n");
				}else {
					// 自行搜索
					matchInfo.append("属性匹配失败,带上推荐方案的衣柜的款式去系统中搜索\n");
					planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
					planProductInfoParam.setProductFilterPropList(planProductInfo.getProductFilterPropList());
					planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
					/*selectOneProduct方法增加过滤属性搜索条件*/
				}
			}
		
		}
		// 水龙头 add by huangsongbo 2018.1.18 ->start
		else if(StringUtils.equals("basic_ltkp", smallTypeValuekey)){
			matchInfo.append("识别为水龙头,按大小类匹配");
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			/*planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));*/
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				matchInfo.append("大小类匹配失败");
				planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
				if(planProductInfoMatched == null){
					matchInfo.append("搜索成功\n");
				}else{
					matchInfo.append("搜索失败\n");
				}
			}else{
				matchInfo.append("大小类匹配成功");
			}
		}
		// 水龙头 add by huangsongbo 2018.1.18 ->end
		else {
			// 其他小类
			planProductInfoMatched = productListMatchOther(planProductInfo, recommendedPlanProductInfoList, matchInfo);
		}
		
		return planProductInfoMatched;
	}
	
	/**
	 * 匹配浴室配件(主要是水龙头)
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param theSameBigTypePlanProductInfoList
	 * @param matchInfo
	 * @return
	 */
	private PlanProductInfo productListMatchBp(PlanProductInfo planProductInfo,
			Map<String, List<PlanProductInfo>> productListmap, StringBuffer matchInfo) {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(productListmap == null) {
			return null;
		}
		// 参数验证 ->end
		
		logger.debug("posName:" + planProductInfo.getPosName());
		List<PlanProductInfo> recommendedPlanProductInfoList = productListmap.get(ProductTypeConstant.PRODUCT_BIG_TYPE_BP);
		String smallTypeValuekey = planProductInfo.getSmallTypeValuekey();
		PlanProductInfo planProductInfoMatched = null;
		if(StringUtils.equals("basic_lybp", smallTypeValuekey)) {
			// 浴缸水龙头
			
			// *匹配参数设置 ->start
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));
			planProductInfoParam.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
			// *匹配参数设置 ->end
			
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				matchInfo.append("匹配失败(按初始化白膜的大小类,属性匹配),准备带推荐方案中浴缸的品牌去系统中搜索\n");
				// 寻找浴缸 ->start
				PlanProductInfo planProductInfoParamBa = new PlanProductInfo();
				planProductInfoParamBa.setBigTypeValuekey(ProductTypeConstant.PRODUCT_BIG_TYPE_BA);
				/*planProductInfoParamBa.setSmallTypeValuekey(ProductTypeConstant.PRODUCT_SMALL_TYPE_BABA);*/
				planProductInfoParamBa.setSmallTypeValueKeyList(Arrays.asList(new String[] {ProductTypeConstant.PRODUCT_SMALL_TYPE_BABA, ProductTypeConstant.PRODUCT_SMALL_TYPE_EDBA}));
				planProductInfoMatched = this.checkDataFromMap(planProductInfoParamBa, productListmap.get(ProductTypeConstant.PRODUCT_BIG_TYPE_BA), true, checkDataFromMapEnum.defaultType);
				// 寻找浴缸 ->end

				if(planProductInfoMatched == null) {
					// 没有浴缸,删除水龙头
					matchInfo.append("检测到推荐方案没有浴缸,删除水龙头");
				}else {
					// 带浴缸品牌搜索
					matchInfo.append("检测到推荐方案有浴缸,优先搜索同浴缸品牌的水龙头,其次搜索无品牌水龙头");
					planProductInfoParam.setOrderBrandId(planProductInfoMatched.getBrandId());
					planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
				}
			}else {
				// 匹配产品属性
				matchInfo.append("匹配成功(按初始化白膜的大小类,属性匹配)(匹配到:" + planProductInfoMatched.getProductCode() + ")\n");
			}
		}
		// 水龙头 add by huangsongbo 2018.1.18 ->start
		else if(StringUtils.equals("basic_ltbp", smallTypeValuekey) || StringUtils.equals("basic_ltba", smallTypeValuekey)){
			matchInfo.append("识别为水龙头,按大小类匹配\n");
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null) {
				matchInfo.append("大小类匹配失败,自行搜索\n");
				planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
				if(planProductInfoMatched == null){
					matchInfo.append("搜索成功\n");
				}else{
					matchInfo.append("搜索失败\n");
				}
			}else{
				matchInfo.append("大小类匹配成功\n");
			}
		}
		// 水龙头 add by huangsongbo 2018.1.18 ->end
		else {
			// 其他小类
			planProductInfoMatched = productListMatchOther(planProductInfo, recommendedPlanProductInfoList, matchInfo);
		}
		
		return planProductInfoMatched;
	}
	
	/**
	 * 匹配其他大类产品
	 * @param planProductInfo
	 * @param recommendedPlanProductInfoList
	 * @param matchInfo
	 * @return
	 */
	private PlanProductInfo productListMatchOther(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo) {
		
		matchInfo.append("正在匹配posName = " + planProductInfo.getPosName() + "; productCode = " + planProductInfo.getProductCode() + ";");
		
		// *匹配参数设置 ->start
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		/*if(StringUtils.equals("basic_frel", planProductInfo.getSmallTypeValuekey())) {
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
		}else {
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
		}*/
		planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
		planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
		// *匹配参数设置 ->end
		
		/*boolean isMatchMatched = true;*/
		// 挂画匹配逻辑单独拎出 update by huangsongbo 2018.1.5
		/*if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM, planProductInfo.getBigTypeValuekey()) && StringUtils.equals("basic_pipe", planProductInfo.getSmallTypeValuekey())) {
			isMatchMatched = false;
		}*/
		
		PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
		/*if(planProductInfoMatched == null && !isMatchMatched) {
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
		}*/
		
		if(planProductInfoMatched == null) {
			// 由匹配白膜大小类变更为匹配产品大小类
			planProductInfoParam.setBigTypeValuekeyInit(null);
			planProductInfoParam.setSmallTypeValuekeyInit(null);
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
			planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
		}
		
		if(planProductInfoMatched == null) {
			matchInfo.append("匹配失败,删除样板房白膜\n");
		}else {
			matchInfo.append("匹配成功\n");
		}
		return planProductInfoMatched;
	}
	
	private PlanProductInfo productListMatchEL(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList, StringBuffer matchInfo) {
		
		// *匹配参数设置 ->start
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		if(StringUtils.equals("basic_tvel", planProductInfo.getSmallTypeValuekey())) {
			planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
			// 过滤属性 ->start
			planProductInfoParam.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
			// 过滤属性 ->end
		}else {
			planProductInfoParam.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfoParam.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
		}
		
		// *匹配参数设置 ->end

		// 特殊处理逻辑:电视柜组合没有匹配上,单独拿出电视做单品匹配,去匹配挂式电视
		/*if(planProductInfo.getMatchFunctionEnum() != null && planProductInfo.getMatchFunctionEnum().equals(MatchFunctionEnum.basic_tvel)) {*/
		if(StringUtils.isNotEmpty(planProductInfo.getMatchFunction()) && StringUtils.equals(IntelligenceDecorationConstant.MATCHFUNCTION_BASIC_TVEL, planProductInfo.getMatchFunction())) {
			
			// new一个挂式电视的过滤属性 ->start
			List<ProductPropsSimple> productFilterPropList = new ArrayList<ProductPropsSimple>();
			ProductPropsSimple productPropsSimple = new ProductPropsSimple();
			productPropsSimple.setIsSort(1);
			productPropsSimple.setKey("placementmode");
			productPropsSimple.setSortValue(99);
			productPropsSimple.setValue(2);
			productFilterPropList.add(productPropsSimple);
			// new一个挂式电视的过滤属性 ->start
			
			planProductInfoParam.setSmallTypeValuekeyInit(null);
			planProductInfoParam.setSmallTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getSmallTypeValuekey()));
			planProductInfoParam.setProductFilterPropList(productFilterPropList);
		}
		
		PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);

		if(planProductInfoMatched == null) {
			matchInfo.append("匹配失败(按初始化白膜的大小类匹配),删除样板房白膜(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
		}else {
			/*if(planProductInfo.getMatchFunctionEnum() != null && planProductInfo.getMatchFunctionEnum().equals(MatchFunctionEnum.basic_tvel)) {*/
			if(StringUtils.isNotEmpty(planProductInfo.getMatchFunction()) && StringUtils.equals(IntelligenceDecorationConstant.MATCHFUNCTION_BASIC_TVEL, planProductInfo.getMatchFunction())) {
				planProductInfo.setInitProductId(planProductInfoMatched.getProductId());
			}
			matchInfo.append("匹配成功(按初始化白膜的大小类匹配)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
		}
		
		return planProductInfoMatched;
	}
	
	/**
	 * 匹配完其他的单品之后,再特殊处理背景墙(由于背景墙匹配规则和其他单品不一样,所以单独拎出)
	 * 
	 * @author huangsongbo
	 * @param productMatchInfoDTOList
	 * @param beijingPlanProductInfoList
	 * @param username 
	 * @param planId 
	 * @param opType 渲染类型
	 * @param designPlanRecommendedId 推荐方案id
	 * @throws IntelligenceDecorationException 
	 */
	private void productListMatchBeijingQiangm(
			List<PlanProductInfo> beijingPlanProductInfoList, 
			List<PlanProductInfo> recommendedPlanProductInfoList,
			List<ProductMatchInfoDTO> productMatchInfoDTOList, 
			Integer planId, 
			String username, 
			Integer opType,
			Integer designPlanRecommendedId
			) throws IntelligenceDecorationException {
		
		String logPrefix = "function:IntelligenceDecorationServiceImpl.productListMatchBeijingQiangm -> ";
		
		// 参数验证 ->start
		if(Lists.isEmpty(beijingPlanProductInfoList)) {
			return;
		}
		if(planId == null) {
			return;
		}
		if(StringUtils.isEmpty(username)) {
			return;
		}
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		if(designPlanRecommendedId == null) {
			logger.error(logPrefix + "designPlanRecommendedId = null");
			return;
		}
		// 参数验证 ->end
		
		// 存结构背景墙的匹配信息
		/*Map<String, PlanProductInfo> structureBeijingMatchInfo = new HashMap<String, ProductListByTypeInfo.PlanProductInfo>();*/
		// posName对应匹配到的PlanProductInfo
		Map<String, PlanProductInfo> mainBeijingMatchInfo = new HashMap<String, ProductListByTypeInfo.PlanProductInfo>();
		// 存所有主墙的匹配信息(用于匹配附墙,ps:附墙根据主墙匹配)
		
		
		// 结构背景墙的附墙/非结构背景墙的附墙,留在最后匹配 ->start
		List<PlanProductInfo> beijingDeputyPlanProductInfoList = new ArrayList<PlanProductInfo>();
		for(int index = 0; index < beijingPlanProductInfoList.size(); index ++) {
			PlanProductInfo planProductInfo = beijingPlanProductInfoList.get(index);
			if(planProductInfo.getGroupType() != null && 1 == planProductInfo.getGroupType().intValue() 
					&& (planProductInfo.getIsMainStructureProduct() == null || 1 != planProductInfo.getIsMainStructureProduct().intValue())) {
				beijingDeputyPlanProductInfoList.add(planProductInfo);
				beijingPlanProductInfoList.remove(index);
				index --;
				continue;
			}
			if(StringUtils.isEmpty(planProductInfo.getWallOrientation())) {
				continue;
			}
			Integer wallOrientationInteger = null;
			try {
				wallOrientationInteger = Integer.valueOf(planProductInfo.getWallOrientation());
			}catch (Exception e) {
				continue;
			}
			if(wallOrientationInteger != null) {
				if(wallOrientationInteger % 100 != 0) {
					// 附墙
					beijingDeputyPlanProductInfoList.add(planProductInfo);
					beijingPlanProductInfoList.remove(index);
					index --;
					continue;
				}
			}
		}
		// 结构背景墙的附墙/非结构背景墙的附墙,留在最后匹配 ->end
		
		// 剔除推荐方案中的附墙 ->start
		this.getMainBeijingProduct(recommendedPlanProductInfoList);
		// 剔除推荐方案中的附墙 ->start
		
		// 统计所有附墙对应的主墙 ->start
		this.setMainProductInfo(beijingDeputyPlanProductInfoList, beijingPlanProductInfoList);
		// 统计所有附墙对应的主墙 ->end
		
		// 获取背景墙分类优先级配置 ->start
		// 墙体分类对应key的map
		Map<String, String> beijingTypePriorityConfMap = Utils.getBeijingTypePriorityConfMap();
		// 获取背景墙分类优先级配置 ->end
		
		// 获取背景墙匹配备用方案配置 ->start
		Map<String, List<String>> standbyConfMap = Utils.getStandbyConfMap();
		// 获取背景墙匹配备用方案配置 ->end
		
		// 统计推荐方案中删除的背景墙 ->start
		List<Map<deletedBeijingProductInfoMapKeyEnum, String>> deletedBeijingProductInfoList = this.getDeletedBeijingProductInfo(designPlanRecommendedId);
		Map<String, Integer> deleteNumInfoRecommendedMap = this.getDeleteNumInfoRecommendedMap(deletedBeijingProductInfoList, beijingTypePriorityConfMap);
		// 统计推荐方案中删除的背景墙 ->end
		
		// 归类样板房背景墙 ->start
		// key对应样板房背景墙信息的map
		Map<String, List<PlanProductInfo>> planProductInfoMapTempletBeijing = this.getPlanProductInfoMapTempletBeijing(beijingPlanProductInfoList, beijingTypePriorityConfMap);
		// 归类样板房背景墙 ->end
		
		// 归类推荐方案背景墙 ->start
		// key对应推荐方案背景墙信息的map
		Map<String, List<PlanProductInfo>> planProductInfoMapRecommendedBeijing = this.getPlanProductInfoMapTempletBeijing(recommendedPlanProductInfoList, beijingTypePriorityConfMap);
		// 归类推荐方案背景墙 ->end
		
		// 获取A类背景墙要删除的背景墙数量 ->start
		Map<String, Integer> deleteNumInfoMap = this.getDeleteNumInfoMapV2(planProductInfoMapTempletBeijing, planProductInfoMapRecommendedBeijing, deleteNumInfoRecommendedMap);
		// 获取A类背景墙要删除的背景墙数量 ->end
		
		// 删除背景墙 ->start
		this.deleteTempletBeijingProductV2(planProductInfoMapTempletBeijing, planProductInfoMapRecommendedBeijing, deleteNumInfoMap);
		// 删除背景墙 ->end
		
		// 先匹配小类,匹配剩下的再按优先级(背景墙小类有一个小类优先级)匹配
		// 现匹配小类
		for(Entry<String, List<PlanProductInfo>> entry : planProductInfoMapTempletBeijing.entrySet()) {
			List<PlanProductInfo> planProductInfoTempletBeijingList = entry.getValue();
			if(Lists.isEmpty(planProductInfoTempletBeijingList)) {
				continue;
			}
			if(planProductInfoMapRecommendedBeijing == null) {
				continue;
			}
			List<PlanProductInfo> planProductInfoRecommendedBeijingList = planProductInfoMapRecommendedBeijing.get(entry.getKey());
			/*if(Lists.isEmpty(planProductInfoRecommendedBeijingList)) {
				continue;
			}*/
			// 第一轮匹配:墙体方位相等 ->start
			for(int index = 0; index < planProductInfoTempletBeijingList.size(); index ++) {
				if(Lists.isEmpty(planProductInfoRecommendedBeijingList)) {
					break;
				}
				PlanProductInfo planProductInfo = planProductInfoTempletBeijingList.get(index);
				logger.debug("------posName:" + planProductInfo.getPosName());
				
				// 不匹配已经删除的背景墙 ->start
				if(!planProductInfo.isNeedBeMatched()) {
					continue;
				}
				// 不匹配已经删除的背景墙 ->end
				
				StringBuffer matchInfo = new StringBuffer();
				matchInfo.append("正在匹配背景墙(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ";full_pave_length:" + planProductInfo.getFullPaveLength() + ")\n");
				
				PlanProductInfo planProductInfoParam = new PlanProductInfo();
				planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
				
				// *设置匹配附加条件(wallType) ->start
				if(StringUtils.isEmpty(planProductInfo.getWallType())) {
					matchInfo.append("该背景墙没有录墙体类型,准备采用墙体优先级匹配方式\n");
					planProductInfo.setMatchInfo(matchInfo.toString());
					continue;
				}
				planProductInfoParam.setWallType(planProductInfo.getWallType());
				planProductInfoParam.setBeijing(true);
				// 设置背景墙长宽过滤(范围)
				/*this.setBeijingMatchParams(planProductInfo, planProductInfoParam);*/
				// *设置匹配附加条件(wallType) ->end
				
				PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, planProductInfoRecommendedBeijingList, false, checkDataFromMapEnum.defaultType);
				
				if(planProductInfoMatched == null) {
					matchInfo.append("背景墙匹配失败(按墙体类别wall_type)(posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + ")\n");
					planProductInfo.setMatchInfo(matchInfo.toString());
					continue;
				}else {
					planProductInfoMatched.setMatched(true);
					matchInfo.append("背景墙类型匹配成功,准备匹配背景墙长高(匹配到" + planProductInfoMatched.getProductCode() + ";styleId = " + planProductInfoMatched.getStyleId() + ")\n");
					// 匹配到了
					// 验证背景墙长高
					this.setBeijingMatchParams(planProductInfo, planProductInfoParam, null);
					planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
					if(this.productMatchCheckMoreInfo(planProductInfoMatched, planProductInfoParam)) {
						// 背景墙长高也符合->匹配成功
						matchInfo.append("背景墙长高匹配成功,背景墙匹配成功\n");
					}else {
						// 没有匹配上,带背景墙的款式+wallType+长宽限制去搜索
						matchInfo.append("背景墙长高匹配失败,款式+长高去系统中搜索\n");
						/*planProductInfoParam.setStyleId(planProductInfoMatched.getStyleId());*/
						planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
						planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
						/*planProductInfoParam.setSmallTypeValuekey(planProductInfoMatched.getSmallTypeValuekey());*/
						planProductInfoParam.setWallType(null);
						planProductInfoParam.setSmallTypeValueList(this.getBeijingValueList());
						planProductInfoParam.setOrderSmallTypeValueKey(planProductInfoMatched.getSmallTypeValuekey());
						String splitTexturesInfoRecommended = planProductInfoMatched.getSplitTexturesChooseInfo();
						Integer productIdRecommended = planProductInfoMatched.getProductId();
						planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
						matchInfo.append(planProductInfoParam.getMatchInfo());
						
						// update by huangsongbo 2018.4.19 ->start
						if(planProductInfoMatched == null) {
							// 背景墙搜索失败,去匹配productLength最接近的背景墙
							planProductInfoMatched = this.selectOneProductNoBeijingProduct(planProductInfoParam, planProductInfo.getProductLength());
						}
						// update by huangsongbo 2018.4.19 ->end
						
						if(planProductInfoMatched == null) {
							matchInfo.append("没有搜索到对应产品,删除背景墙\n");
							ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
							productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
							productMatchInfoDTO.setWallType(WallTypeConstant.BEIJING);
							productMatchInfoDTO.setMatchInfo(matchInfo.toString());
							productMatchInfoDTOList.add(productMatchInfoDTO);
							planProductInfoTempletBeijingList.remove(index);
							index --;
						}else {
							matchInfo.append("搜索到对应产品\n");
							// 匹配材质
							String splitTexturesInfo = designPlanProductService.matchSplitTexturesInfo(planProductInfoMatched.getSplitTexturesChooseInfo(), productIdRecommended, splitTexturesInfoRecommended);
							planProductInfoMatched.setSplitTexturesChooseInfo(splitTexturesInfo);
						}
					}
				}
				
				if(planProductInfoMatched != null) {
					
					// 记录结构背景墙的匹配 ->start
					/*if(StringUtils.isNotEmpty(planProductInfo.getPlanGroupId()) 
							&& planProductInfo.getGroupType() != null 
							&& planProductInfo.getGroupType() == 1) {
						structureBeijingMatchInfo.put(planProductInfo.getPlanGroupId(), planProductInfoMatched);
					}*/
					mainBeijingMatchInfo.put(planProductInfo.getPosName(), planProductInfoMatched);
					// 记录结构背景墙的匹配 ->end
					
					ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
					productMatchInfoDTO.setWallType(WallTypeConstant.BEIJING);
					productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
					productMatchInfoDTO.setProductCode(planProductInfoMatched.getProductCode());
					
					PlanProductInfo planProductInfoMatchedCopy = planProductInfoMatched.clone();
					
					planProductInfoMatchedCopy.setInitProductId(planProductInfo.getInitProductId());
					planProductInfoMatchedCopy.setGroupType(planProductInfo.getGroupType());
					planProductInfoMatchedCopy.setPlanGroupId(planProductInfo.getPlanGroupId());
					planProductInfoMatchedCopy.setGroupOrStructureId(planProductInfo.getGroupOrStructureId());
					planProductInfoMatchedCopy.setIsMainStructureProduct(planProductInfo.getIsMainStructureProduct());
					planProductInfoMatchedCopy.setIsGroupReplaceWay(planProductInfo.getIsGroupReplaceWay());
					planProductInfoMatchedCopy.setProductIndex(planProductInfo.getProductIndex());
					
					// update by huangsongbo 2018.4.27 ->start
					planProductInfoMatchedCopy.setWallType(planProductInfo.getWallType());
					planProductInfoMatchedCopy.setWallOrientation(planProductInfo.getWallOrientation());
					// update by huangsongbo 2018.4.27 ->end
					
					Integer designPlanProductId = designPlanProductService.createByPlanProductInfo(planProductInfoMatchedCopy, planId, username, opType);
					productMatchInfoDTO.setDesignPlanProductId(designPlanProductId);
					productMatchInfoDTO.setMatchInfo(matchInfo.toString());
					productMatchInfoDTO.setBigTypeValuekey(planProductInfoMatched.getBigTypeValuekey());
					productMatchInfoDTO.setSmallTypeValuekey(planProductInfoMatched.getSmallTypeValuekey());
					productMatchInfoDTOList.add(productMatchInfoDTO);
					planProductInfoTempletBeijingList.remove(index);
					index --;
				}else {
					planProductInfo.setMatchInfo(matchInfo.toString());
					// 如果没有匹配上产品,存原样板房数据 update by huangsongbo 2017.12.26 ->start
					/*planProductInfo.setIsDeleted(1);
					designPlanProductService.createByPlanProductInfo(planProductInfo, planId, username, opType);*/
					// 如果没有匹配上产品,存原样板房数据 update by huangsongbo 2017.12.26 ->end
				}
			}
			// 第一轮匹配:墙体方位相等 ->end
			
			// 第二轮匹配:墙体类型优先级 ->start
			for(int index = 0; index < planProductInfoTempletBeijingList.size(); index ++) {
				PlanProductInfo planProductInfo = planProductInfoTempletBeijingList.get(index);
				logger.debug("------posName:" + planProductInfo.getPosName());
				
				// 不匹配已经删除的背景墙 ->start
				if(!planProductInfo.isNeedBeMatched()) {
					continue;
				}
				// 不匹配已经删除的背景墙 ->end
				
				StringBuffer matchInfo = new StringBuffer(planProductInfo.getMatchInfo() == null ? "" : planProductInfo.getMatchInfo());
				
				PlanProductInfo planProductInfoParam = new PlanProductInfo();
				planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
				planProductInfoParam.setBeijing(true);
				
				matchInfo.append("背景墙按正在按优先级匹配\n");
				PlanProductInfo planProductInfoMatched = this.productListMatchBeijingQiangmScoreV2(planProductInfo, planProductInfoRecommendedBeijingList);
				
				if(planProductInfoMatched == null) {
					// 启动备用方案:BeijingTypePriorityBean.standby ->start
					if(standbyConfMap.containsKey(entry.getKey())) {
						List<String> standbyWallTypeList = standbyConfMap.get(entry.getKey());
						if(Lists.isNotEmpty(standbyWallTypeList)) {
							for(String wallType : standbyWallTypeList) {
								planProductInfoParam.setWallType(wallType);
								planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, recommendedPlanProductInfoList, true, checkDataFromMapEnum.defaultType);
								if(planProductInfoMatched != null) {
									break;
								}
							}
							planProductInfoParam.setWallType(null);
						}
					}
					// 启动备用方案:BeijingTypePriorityBean.standby ->end
				}
				
				if(planProductInfoMatched == null) {
					matchInfo.append("背景墙按优先级匹配失败\n");
					
				}else {
					// 长宽匹配
					matchInfo.append("背景墙按优先级匹配成功,验证长高是否匹配(匹配到" + planProductInfoMatched.getProductCode() + ";styleId = " + planProductInfoMatched.getStyleId() + ")\n");
					planProductInfoMatched.setMatched(true);
					this.setBeijingMatchParams(planProductInfo, planProductInfoParam, null);
					planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
					if(this.productMatchCheckMoreInfo(planProductInfoMatched, planProductInfoParam)) {
						// 背景墙长高也符合->匹配成功
						matchInfo.append("背景墙长高匹配成功,背景墙匹配成功\n");
					}else {
						// 没有匹配上,带背景墙的款式+wallType+长宽限制去搜索
						matchInfo.append("背景墙长高匹配失败,准备带背景墙类型+款式+长高去系统中搜索\n");
						/*planProductInfoParam.setStyleId(planProductInfoMatched.getStyleId());*/
						planProductInfoParam.setOrderStyleId(planProductInfoMatched.getStyleId());
						planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
						planProductInfoParam.setWallType(null);
						planProductInfoParam.setSmallTypeValueList(this.getBeijingValueList());
						planProductInfoParam.setOrderSmallTypeValueKey(planProductInfoMatched.getSmallTypeValuekey());
						String splitTexturesInfoRecommended = planProductInfoMatched.getSplitTexturesChooseInfo();
						Integer productIdRecommended = planProductInfoMatched.getProductId();
						planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
						matchInfo.append(planProductInfoParam.getMatchInfo());
						
						// update by huangsongbo 2018.4.19 ->start
						if(planProductInfoMatched == null) {
							// 背景墙搜索失败,去匹配productLength最接近的背景墙
							planProductInfoMatched = this.selectOneProductNoBeijingProduct(planProductInfoParam, planProductInfo.getProductLength());
						}
						// update by huangsongbo 2018.4.19 ->end
						
						if(planProductInfoMatched == null) {
							matchInfo.append("没有搜索到对应产品\n");
						}else {
							matchInfo.append("搜索到对应产品\n");
							// 匹配材质
							String splitTexturesInfo = designPlanProductService.matchSplitTexturesInfo(planProductInfoMatched.getSplitTexturesChooseInfo(), productIdRecommended, splitTexturesInfoRecommended);
							planProductInfoMatched.setSplitTexturesChooseInfo(splitTexturesInfo);
						}
					}
				}
				
				if(planProductInfoMatched != null) {
					
					// 记录结构背景墙的匹配 ->start
					/*if(StringUtils.isNotEmpty(planProductInfo.getPlanGroupId()) 
							&& planProductInfo.getGroupType() != null 
							&& planProductInfo.getGroupType() == 1) {
						structureBeijingMatchInfo.put(planProductInfo.getPlanGroupId(), planProductInfoMatched);
					}*/
					mainBeijingMatchInfo.put(planProductInfo.getPosName(), planProductInfoMatched);
					// 记录结构背景墙的匹配 ->end
					
					ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
					productMatchInfoDTO.setWallType(WallTypeConstant.BEIJING);
					productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
					
					PlanProductInfo planProductInfoMatchedCopy = planProductInfoMatched.clone();
					
					productMatchInfoDTO.setProductCode(planProductInfoMatchedCopy.getProductCode());
					planProductInfoMatchedCopy.setInitProductId(planProductInfo.getInitProductId());
					planProductInfoMatchedCopy.setGroupType(planProductInfo.getGroupType());
					planProductInfoMatchedCopy.setPlanGroupId(planProductInfo.getPlanGroupId());
					planProductInfoMatchedCopy.setGroupOrStructureId(planProductInfo.getGroupOrStructureId());
					planProductInfoMatchedCopy.setIsMainStructureProduct(planProductInfo.getIsMainStructureProduct());
					planProductInfoMatchedCopy.setIsGroupReplaceWay(planProductInfo.getIsGroupReplaceWay());
					planProductInfoMatchedCopy.setProductIndex(planProductInfo.getProductIndex());
					
					// update by huangsongbo 2018.4.27 ->start
					planProductInfoMatchedCopy.setWallType(planProductInfo.getWallType());
					planProductInfoMatchedCopy.setWallOrientation(planProductInfo.getWallOrientation());
					// update by huangsongbo 2018.4.27 ->end
					
					Integer designPlanProductId = designPlanProductService.createByPlanProductInfo(planProductInfoMatchedCopy, planId, username, opType);
					productMatchInfoDTO.setDesignPlanProductId(designPlanProductId);
					productMatchInfoDTO.setMatchInfo(matchInfo.toString());
					productMatchInfoDTO.setBigTypeValuekey(planProductInfoMatched.getBigTypeValuekey());
					productMatchInfoDTO.setSmallTypeValuekey(planProductInfoMatched.getSmallTypeValuekey());
					productMatchInfoDTOList.add(productMatchInfoDTO);
					planProductInfoTempletBeijingList.remove(index);
					index --;
					continue;
				}else {
					planProductInfo.setMatchInfo(matchInfo.toString());
					// 如果没有匹配上产品,存原样板房数据 update by huangsongbo 2017.12.26 ->start
					/*planProductInfo.setIsDeleted(1);
					designPlanProductService.createByPlanProductInfo(planProductInfo, planId, username, opType);*/
					// 如果没有匹配上产品,存原样板房数据 update by huangsongbo 2017.12.26 ->end
				}
				
			}
			// 第二轮匹配:墙体类型优先级 ->end
		}
		
		// 待删除的背景墙list
		List<PlanProductInfo> beijingPlanProductInfoNeedDeleteList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
		
		// 匹配剩下的结构结构背景墙(非主墙),按主墙的款式匹配 ->start
		for(int index = 0; index < beijingDeputyPlanProductInfoList.size(); index ++) {
			PlanProductInfo planProductInfo = beijingDeputyPlanProductInfoList.get(index);
			logger.debug("------posName:" + planProductInfo.getPosName());
			/*PlanProductInfo planProductInfoStructure = structureBeijingMatchInfo.get(planProductInfo.getPlanGroupId());*/
			PlanProductInfo planProductInfoStructure = mainBeijingMatchInfo.get(planProductInfo.getMainProductPosName());
			if(planProductInfoStructure != null) {
				PlanProductInfo planProductInfoParam = new PlanProductInfo();
				planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
				planProductInfoParam.setBeijing(true);
				this.setBeijingMatchParams(planProductInfo, planProductInfoParam, null);
				planProductInfoParam.setProductHeight(planProductInfo.getProductHeight());
				planProductInfoParam.setSmallTypeValueList(this.getBeijingValueList());
				/*planProductInfoParam.setStyleId(planProductInfoStructure.getStyleId());*/
				planProductInfoParam.setOrderStyleId(planProductInfoStructure.getStyleId());
				planProductInfoParam.setOrderProductModelNumber(planProductInfoStructure.getProductModelNumber());
				planProductInfoParam.setOrderSmallTypeValueKey(planProductInfoStructure.getSmallTypeValuekey());
				PlanProductInfo planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
				/*if(planProductInfoMatched == null) {
					planProductInfoParam.setStyleId(null);
					planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
				}*/
				
				// update by huangsongbo 2018.4.19 ->start
				if(planProductInfoMatched == null) {
					// 背景墙搜索失败,去匹配productLength最接近的背景墙
					planProductInfoMatched = this.selectOneProductNoBeijingProduct(planProductInfoParam, planProductInfo.getProductLength());
				}
				// update by huangsongbo 2018.4.19 ->end
				
				if(planProductInfoMatched != null) {
					ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
					productMatchInfoDTO.setWallType(WallTypeConstant.BEIJING);
					productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
					productMatchInfoDTO.setProductCode(planProductInfoMatched.getProductCode());
					
					PlanProductInfo planProductInfoMatchedCopy = planProductInfoMatched.clone();
					
					planProductInfoMatchedCopy.setInitProductId(planProductInfo.getInitProductId());
					planProductInfoMatchedCopy.setGroupType(planProductInfo.getGroupType());
					planProductInfoMatchedCopy.setPlanGroupId(planProductInfo.getPlanGroupId());
					planProductInfoMatchedCopy.setGroupOrStructureId(planProductInfo.getGroupOrStructureId());
					planProductInfoMatchedCopy.setIsMainStructureProduct(planProductInfo.getIsMainStructureProduct());
					planProductInfoMatchedCopy.setIsGroupReplaceWay(planProductInfo.getIsGroupReplaceWay());
					planProductInfoMatchedCopy.setProductIndex(planProductInfo.getProductIndex());
					
					// 多材质匹配主墙的多材质 update by huangsongbo 2017.12.19 ->start
					String splitTexturesInfo = designPlanProductService.matchSplitTexturesInfo(planProductInfoMatchedCopy.getSplitTexturesChooseInfo(), planProductInfoStructure.getProductId(), planProductInfoStructure.getSplitTexturesChooseInfo());
					planProductInfoMatchedCopy.setSplitTexturesChooseInfo(splitTexturesInfo);
					// 多材质匹配主墙的多材质 update by huangsongbo 2017.12.19 ->start
					
					// update by huangsongbo 2018.4.27 ->start
					planProductInfoMatchedCopy.setWallType(planProductInfo.getWallType());
					planProductInfoMatchedCopy.setWallOrientation(planProductInfo.getWallOrientation());
					// update by huangsongbo 2018.4.27 ->end
					
					Integer designPlanProductId = designPlanProductService.createByPlanProductInfo(planProductInfoMatchedCopy, planId, username, opType);
					productMatchInfoDTO.setDesignPlanProductId(designPlanProductId);
					productMatchInfoDTO.setBigTypeValuekey(planProductInfoMatched.getBigTypeValuekey());
					productMatchInfoDTO.setSmallTypeValuekey(planProductInfoMatched.getSmallTypeValuekey());
					productMatchInfoDTOList.add(productMatchInfoDTO);
					continue;
				}else {
					// 没有匹配到,删除背景墙
					beijingPlanProductInfoNeedDeleteList.add(planProductInfo);
				}
			}else {
				// 主墙没有匹配到背景墙,则附墙也删除
				beijingPlanProductInfoNeedDeleteList.add(planProductInfo);
			}
		}
		// 匹配剩下的结构结构背景墙(非主墙),按主墙的款式匹配 ->end
		
		// *处理剩下没有匹配的背景墙(删除,只设置delPosName) ->start
		for(Entry<String, List<PlanProductInfo>> entry : planProductInfoMapTempletBeijing.entrySet()) {
			List<PlanProductInfo> planProductInfoTempletBeijingList = entry.getValue();
			if(Lists.isEmpty(planProductInfoTempletBeijingList)) {
				continue;
			}
			for(PlanProductInfo planProductInfo : planProductInfoTempletBeijingList) {
				beijingPlanProductInfoNeedDeleteList.add(planProductInfo);
			}
		}
		
		for(PlanProductInfo planProductInfo : beijingPlanProductInfoNeedDeleteList) {
			ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
			productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
			productMatchInfoDTO.setWallType(WallTypeConstant.BEIJING);
			productMatchInfoDTO.setMatchInfo(planProductInfo.getMatchInfo());
			productMatchInfoDTOList.add(productMatchInfoDTO);
			
			// 没有匹配到背景墙,也要存一份is_deleted = 1的数据update by huangsongbo ->start
			planProductInfo.setIsDeleted(1);
			designPlanProductService.createByPlanProductInfo(planProductInfo, planId, username, opType);
			// 没有匹配到背景墙,也要存一份is_deleted = 1的数据update by huangsongbo ->end
		}
		// *处理剩下没有匹配的背景墙(删除,只设置delPosName) ->end
	}
	
	/**
	 * 挂画匹配需求改版,先按墙体分类匹配一波,然后再按墙体分类优先级匹配一波,同背景墙
	 * 
	 * add by huangsongbo 2018.3.9
	 * @author huangsongbo
	 * @param pipePlanProductInfoList
	 * @param productListmap
	 * @param productMatchInfoDTOList
	 * @param planId
	 * @param username
	 * @param opType
	 * @throws IntelligenceDecorationException 
	 */
	@SuppressWarnings("unchecked")
	private void productListMatchPipeV2(List<PlanProductInfo> pipePlanProductInfoList,
			List<PlanProductInfo> planProductInfoPeRecommendedList, List<ProductMatchInfoDTO> productMatchInfoDTOList,
			Integer planId, String username, Integer opType) throws IntelligenceDecorationException {
		// 参数验证 ->start
		if(Lists.isEmpty(pipePlanProductInfoList)) {
			return;
		}
		if(Lists.isEmpty(planProductInfoPeRecommendedList)) {
			return;
		}
		if(Lists.isEmpty(productMatchInfoDTOList)) {
			return;
		}
		if(planId == null) {
			return;
		}
		if(StringUtils.isEmpty(username)) {
			return;
		}
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		// 参数验证 ->end
		
		// 整理出能被样板房中挂画匹配到的产品 ->start
		for (int index = 0; index < planProductInfoPeRecommendedList.size(); index++) {
			PlanProductInfo planProductInfo = planProductInfoPeRecommendedList.get(index);
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(ProductTypeConstant.PRODUCT_BIG_TYPE_PE);
			Map<getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum, Object> smallTypeListProperties = baseProductService.getSmallTypeValueListBySmallTypeValueKey(ProductTypeConstant.PRODUCT_SMALL_TYPE_BASIC_PIPE);
			if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in)) {
				planProductInfoParam.setSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in));
				planProductInfoParam.setSmallTypeValueKeyList((List<String>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.inKey));
			}else {
				if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn)) {
					planProductInfoParam.setExcludeSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn));
				}
			}
			boolean flag = this.productMatchCheckMoreInfo(planProductInfo, planProductInfoParam);
			if(!flag) {
				planProductInfoPeRecommendedList.remove(index);
				index --;
			}
		}
		// 整理出能被样板房中挂画匹配到的产品 ->end
		
		// 第一轮匹配:匹配墙体分类的挂画 ->start
		for (int index = 0; index < pipePlanProductInfoList.size(); index++) {
			PlanProductInfo planProductInfo = pipePlanProductInfoList.get(index);
			StringBuffer matchInfo = new StringBuffer();
			matchInfo.append("正在匹配posName:" + planProductInfo.getPosName() + ";productCode:" + planProductInfo.getProductCode() + "\n");
			PlanProductInfo planProductInfoParam = new PlanProductInfo();
			planProductInfoParam.setBigTypeValuekey(Utils.baimoSmallTypeKeyToSmallTypeKey(planProductInfo.getBigTypeValuekey()));
			planProductInfoParam.setWallType(planProductInfo.getWallType());
			PlanProductInfo planProductInfoMatched = this.checkDataFromMap(planProductInfoParam, planProductInfoPeRecommendedList, true, checkDataFromMapEnum.defaultType);
			if(planProductInfoMatched == null){
				matchInfo.append("没有匹配上同墙体类型的挂画\n");
				planProductInfo.setMatchInfo(matchInfo.toString());
				/*pipePlanProductInfoListSecond.add(planProductInfo);*/
			}else{
				matchInfo.append("匹配上同墙体类型的挂画\n");
				ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
				productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
				this.getProductMatchInfoDTO(planId, username, opType, planProductInfo, matchInfo, productMatchInfoDTO, planProductInfoMatched);
				productMatchInfoDTOList.add(productMatchInfoDTO);
				pipePlanProductInfoList.remove(index);
				index --;
			}
		}
		// 第一轮匹配:匹配墙体分类的挂画 ->end
		
		// 第二轮匹配墙体类型优先级匹配 ->start
		for (int index = 0; index < pipePlanProductInfoList.size(); index++) {
			PlanProductInfo planProductInfo = pipePlanProductInfoList.get(index);
			PlanProductInfo planProductInfoMatched = this.productListMatchBeijingQiangmScoreV2(planProductInfo, planProductInfoPeRecommendedList);
			if(planProductInfoMatched == null) {
				
			}else {
				StringBuffer matchInfo = new StringBuffer(planProductInfo.getMatchInfo() == null ? "" : planProductInfo.getMatchInfo());
				matchInfo.append("挂画匹配成功(按优先级)\n");
				ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
				productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
				this.getProductMatchInfoDTO(planId, username, opType, planProductInfo, matchInfo, productMatchInfoDTO, planProductInfoMatched);
				productMatchInfoDTOList.add(productMatchInfoDTO);
				pipePlanProductInfoList.remove(index);
				index --;
			}
		}
		// 墙体类型优先级匹配 ->end
		
		// 没匹配上的挂画删除 ->start
		for(PlanProductInfo planProductInfo : pipePlanProductInfoList) {
			ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
			productMatchInfoDTO.setDelPosName(planProductInfo.getPosName());
			productMatchInfoDTO.setWallType(WallTypeConstant.BEIJING);
			productMatchInfoDTO.setMatchInfo(planProductInfo.getMatchInfo());
			productMatchInfoDTOList.add(productMatchInfoDTO);
		}
		// 没匹配上的挂画删除 ->end
		
	}
	
	/**
	 * 匹配系列
	 * 
	 * @author huangsongbo
	 * @param seriesProductInfoMap 待匹配的系列产品信息
	 * @param productListmap 推荐方案中所有产品
	 * @param productMatchInfoDTOList 返回结果集
	 * @param matchType 0:全屋替换;1:硬装替换
	 * @throws IntelligenceDecorationException 
	 */
	private void productListMatchSeries(Map<String, List<PlanProductInfo>> seriesProductInfoMap,
			Map<String, List<PlanProductInfo>> productListmap,
			List<ProductMatchInfoDTO> productMatchInfoDTOList,
			Integer planId,
			String username,
			Integer opType, Integer matchType
			) throws IntelligenceDecorationException {
		// 参数验证/处理 ->start
		if(seriesProductInfoMap == null) {
			return;
		}
		if(productListmap == null) {
			return;
		}
		if(productMatchInfoDTOList == null) {
			return;
		}
		if(matchType == null) {
			matchType = 0;
		}
		// 参数验证/处理 ->end
		
		// 检测油烟机柜是否被删除 ->start
		boolean isDeleteedDyki = true;
		// 油烟机柜大类
		String bigTypeDgki = "dgki";
		// 油烟机柜小类
		String smallTypeDgki = "dyki";
		if(productListmap.containsKey(bigTypeDgki)) {
			List<PlanProductInfo> planProductInfoListDgki = productListmap.get(bigTypeDgki);
			if(Lists.isNotEmpty(planProductInfoListDgki)) {
				for(PlanProductInfo planProductInfo : planProductInfoListDgki) {
					if(StringUtils.equals(smallTypeDgki, planProductInfo.getSmallTypeValuekey())) {
						isDeleteedDyki = false;
						break;
					}
				}
			}
		}
		// 检测油烟机柜是否被删除 ->end
		
		// 系列对应的匹配产品(所有同组系列的产品,都按这个匹配到的产品的信息进行搜索)
		Map<String, PlanProductInfo> seriesMatchInfoMap = this.getSeriesMatchInfoMap(seriesProductInfoMap, productListmap);
		for(String key : seriesProductInfoMap.keySet()) {
			List<PlanProductInfo> templetPlanProductInfoList = seriesProductInfoMap.get(key);
			if(Lists.isNotEmpty(templetPlanProductInfoList)) {
				for(PlanProductInfo templetPlanProductInfo : templetPlanProductInfoList) {
					logger.debug("posName:" + templetPlanProductInfo.getPosName() + "productCode:" + templetPlanProductInfo.getProductCode());
					// test ->start
					/*if(StringUtils.equals("ctyki01", templetPlanProductInfo.getPosName())) {
						logger.debug("posName:" + templetPlanProductInfo.getPosName());
					}*/
					// test ->end
					// 根据系列匹配到的产品带上自身白膜属性自行搜索
					StringBuffer matchInfo = new StringBuffer();
					matchInfo.append("开始匹配posname:" + templetPlanProductInfo.getPosName() + ";productCode:" + templetPlanProductInfo.getProductCode() + "\n");
					ProductMatchInfoDTO productMatchInfoDTO = new BedroomProductMatchDTO().new ProductMatchInfoDTO();
					PlanProductInfo planProductInfoMatched = null;
					if(0 == matchType) {
						// 如果推荐方案中油烟机柜删除,一键生成的方案也要删除
						if(StringUtils.equals("basic_" + smallTypeDgki, templetPlanProductInfo.getSmallTypeValuekey()) && isDeleteedDyki) {
							planProductInfoMatched = null;
						}else {
							planProductInfoMatched =	this.getProductMatchInfoDTOSeries(templetPlanProductInfo, seriesMatchInfoMap.get(key), matchInfo);
						}
					}else {
						planProductInfoMatched = templetPlanProductInfo.clone();
					}
					productMatchInfoDTO.setDelPosName(templetPlanProductInfo.getPosName());
					this.getProductMatchInfoDTO(planId, username, opType, templetPlanProductInfo, matchInfo, productMatchInfoDTO, planProductInfoMatched);
					productMatchInfoDTOList.add(productMatchInfoDTO);
				}
			}
		}
	}
	
	/**
	 * 组装StructureMatchInfoDTO
	 * 
	 * @author huangsongbo
	 * @param planStructureInfoList 匹配上的结构的产品list(推荐方案中)
	 * @param planId
	 * @param username
	 * @param center
	 * @param regionMark
	 * @param measureCode
	 * @param opType
	 * @param object2 
	 * @param object 
	 * @return
	 * @throws IntelligenceDecorationException 
	 */
	private StructureMatchInfoDTO getStructureMatchInfoDTO(
			List<PlanProductInfo> planStructureInfoList,
			Integer planId, String username, String center,
			String regionMark, String measureCode, Integer opType, Integer productStructureId, String planStructureRegionMark) throws IntelligenceDecorationException {
		
		// *参数验证 ->start
		if(Lists.isEmpty(planStructureInfoList)) {
			logger.error("function:IntelligenceDecorationServiceImpl.getStructureMatchInfoDTO(....)->\n参数planStructureInfoList = null");
			return null;
		}
		if(planId == null) {
			logger.error("function:IntelligenceDecorationServiceImpl.getStructureMatchInfoDTO(....)->\n参数planStructureId:planId = null");
			return null;
		}
		if(StringUtils.isEmpty(username)) {
			logger.error("function:IntelligenceDecorationServiceImpl.getStructureMatchInfoDTO(....)->\n参数(StringUtils.isEmpty(username)) = true");
			return null;
		}
		String planStructureId = planStructureInfoList.get(0).getPlanGroupId();
		if(StringUtils.isEmpty(planStructureId)) {
			logger.error("function:IntelligenceDecorationServiceImpl.getStructureMatchInfoDTO(....)->\n"
					+ "String planStructureId = planStructureInfoList.get(0).getPlanGroupId()->planStructureId = null");
			return null;
		}
		if (opType == null) {
			opType = DesignPlanConstants.USER_RENDER;
		}
		// *参数验证 ->end
		
		StructureMatchInfoDTO structureMatchInfoDTO = new BedroomProductMatchDTO().new StructureMatchInfoDTO();
		List<DetailInfo> structureDetailInfoList = new ArrayList<DetailInfo>();
		
		String newPlanStructureId = null;
		Integer groupOrStructureId = null;
		String flag = Utils.generateRandomDigitString(12);
		if(planStructureId.indexOf("_") != -1) {
			groupOrStructureId = Integer.valueOf(planStructureId.substring(0, planStructureId.indexOf("_")));
			newPlanStructureId = groupOrStructureId + "_" + flag;
		}else {
			throw new RuntimeException("匹配结构成功,生成新的结构plan_group_id失败:没有获取到推荐方案中结构的plan_group_id or plan_group_id格式不正确;");
		}
		
		for(PlanProductInfo planProductInfo : planStructureInfoList) {
			planProductInfo.setGroupOrStructureId(groupOrStructureId);
			planProductInfo.setGroupType(1);
			planProductInfo.setPlanGroupId(newPlanStructureId);
			planProductInfo.setIsMainProduct(0);
			planProductInfo.setCenter(center);
			planProductInfo.setRegionMark(regionMark);
			planProductInfo.setMeasureCode(measureCode);
			Integer designPlanProductId = designPlanProductService.createByPlanProductInfo(planProductInfo, planId, username, opType);
			DetailInfo detailInfo = new BedroomProductMatchDTO().new DetailInfo();
			detailInfo.setDesignPlanProductId(designPlanProductId);
			detailInfo.setRecommendedPlanProductCode(planProductInfo.getProductCode());
			detailInfo.setRecommendedPlanProductPosName(planProductInfo.getPosName());
			detailInfo.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
			detailInfo.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey());
			detailInfo.setBasicModelCode(planProductInfo.getInitProductCode());
			detailInfo.setMatchedPosName(planProductInfo.getMatchedPosName());
			structureDetailInfoList.add(detailInfo);
		}
		
		// *结构配置文件路径 ->start
		String structureConfig = null;
		StructureProduct structureProduct = structureProductService.get(groupOrStructureId);
		if(structureProduct == null) {
			/*throw new RuntimeException("结构未找到,structureId:" + groupOrStructureId);*/
			throw new IntelligenceDecorationException("推荐方案中某个结构的相关信息已经被删除");
		}
		Integer configId = structureProduct.getConfigFileId();
		if(configId == null) {
			/*throw new RuntimeException("结构的配置文件id为空,structureId:" + groupOrStructureId);*/
			throw new IntelligenceDecorationException("推荐方案中某个结构的配置文件id为空");
		}
		ResFile resFile = resFileService.get(configId);
		if(resFile == null) {
			/*throw new RuntimeException("配置文件没有找到,resFileId:" + configId);*/
			throw new IntelligenceDecorationException("推荐方案中某个结构的配置文件没有找到");
		}
		/*structureConfig = resFile.getFilePath();*/
		structureConfig=FileUploadUtils.getFileContext(Utils.getAbsolutePath(resFile.getFilePath(), null));
		// *结构配置文件路径 ->end
		
		structureMatchInfoDTO.setStructureDetailInfoList(structureDetailInfoList);
		/*structureMatchInfoDTO.setNewPlanStructureId(newPlanStructureId);*/
		structureMatchInfoDTO.setStructureConfig(structureConfig);
		structureMatchInfoDTO.setDelStructureRegionMark(regionMark);
		structureMatchInfoDTO.setProductStructureId(productStructureId);
		structureMatchInfoDTO.setPlanStructureRegionMark(planStructureRegionMark);
		return structureMatchInfoDTO;
	}
	
	/**
	 * 结构匹配
	 * 
	 * @author huangsongbo
	 * @param templetMainPlanProductInfo 参照结构信息
	 * @param planStructureMainProudctMap 结构list(被匹配的推荐方案中的结构)
	 * @param matchInfo 记录匹配信息
	 * @param planStructureProudctListMap 
	 * @param productListmap 推荐方案产品信息,为了结构没有匹配上对应的贴图而做的备用方案
	 * @param designTempletId 一键装修的样板房id:用于自行搜索墙面结构(墙面结构暂定为定制结构)
	 * @param groundIdentify 样板房地面布局标识
	 * @return 
	 * @throws IntelligenceDecorationException 
	 */
	/*private List<PlanProductInfo> structureMatch(*/
	private Map<String, Object> structureMatch(
			PlanProductInfo templetMainPlanProductInfo,
			Map<String, PlanProductInfo> planStructureMainProudctMap, StringBuffer matchInfo,
			Map<String, List<PlanProductInfo>> planStructureProudctListMap,
			Map<String, List<PlanProductInfo>> productListmap,
			Integer designTempletId, String groundIdentify
			) throws IntelligenceDecorationException {
		
		// *参数验证 ->start
		if(templetMainPlanProductInfo == null) {
			return null;
		}
		if(planStructureMainProudctMap == null) {
			return null;
		}
		if(designTempletId == null){
			return null;
		}
		
		Map<String, Object> returnMap = new HashMap<String, Object>();
		// 匹配成功(或者匹配失败参照该结构搜索)的推荐方案中的结构id
		Integer productStructureId = null;
		// 匹配成功(或者匹配失败参照该结构搜索)的推荐方案中的结构区域标识
		String planStructureRegionMark = null;
		// 返回的结构明细信息
		List<PlanProductInfo> planProductInfoListMatched = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
		
		// 地面结构匹配区别于墙面结构匹配
		if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM, templetMainPlanProductInfo.getBigTypeValuekey())) {
			// 匹配墙面结构
			// 检测推荐方案中有没有墙面结构,如果有的话,直接匹配上
			for(String key : planStructureMainProudctMap.keySet()) {
				PlanProductInfo planProductInfo = planStructureMainProudctMap.get(key);
				if(StringUtils.equals(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM, planProductInfo.getBigTypeValuekey())) {
					// 匹配上,根据匹配的结构的属性自行搜索墙面结构
					
					if(StringUtils.isNotEmpty(planProductInfo.getPlanGroupId())) {
						try {
							planProductInfo.setGroupOrStructureId(Integer.valueOf(planProductInfo.getPlanGroupId().split("_")[0]));
						}catch (Exception e) {
							logger.error(e.toString());
						}
					}
					
					planProductInfoListMatched = this.selectOneStructureAndMatchProductForQiangm(
							planProductInfo.getGroupOrStructureId(),
							planStructureProudctListMap.get(planProductInfo.getPlanGroupId()),
							productListmap, designTempletId, matchInfo);
					break;
				}
			}
		}else {
			// 注释原因:户型绘制功能上线之后,结构相关的功能逻辑完全变化(结构改为拼花) update by huangsongbo 2018.3.16
			
			/*// 匹配地面结构
			// 区域标识
			String regionMark = templetMainPlanProductInfo.getRegionMark();
			// 是否需要匹配地面布局标识
			boolean idNeedMatchProductSmallpoxIdentify = false;
			if(groundIdentify != null && groundIdentify != 0) {
			if(!StringUtils.equals("0", groundIdentify)) {
				idNeedMatchProductSmallpoxIdentify = true;
			}
			if(StringUtils.isEmpty(regionMark)) {
				matchInfo.append("样板房产品表中,结构的区域标识没有录,无法匹配,只能去系统中搜索(templet_plan_group_id:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
				matchInfo.append("样板房产品表中,结构的区域标识没有录,无法匹配(templet_plan_group_id:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
				return null;
			}
			// 尺寸编码
			String measureCode = templetMainPlanProductInfo.getMeasureCode();
			if(StringUtils.isEmpty(measureCode)) {
				matchInfo.append("样板房产品表中,结构的尺寸编码没有录,无法匹配,也无法搜索(templet_plan_group_id:" + templetMainPlanProductInfo.getPlanGroupId() + ")\n");
				return null;
			}
			// *参数验证 ->end
			
			String planStructureId = null;
			
			// 第一轮正常匹配 ->start
			matchInfo.append("正在进行区域标识匹配\n");
			for(String key : planStructureMainProudctMap.keySet()) {
				
				PlanProductInfo planProductInfo = planStructureMainProudctMap.get(key);
				if(StringUtils.isNotEmpty(planProductInfo.getPlanGroupId())) {
					try {
						planProductInfo.setGroupOrStructureId(Integer.valueOf(planProductInfo.getPlanGroupId().split("_")[0]));
					}catch (Exception e) {
						logger.error(e);
					}
				}
				
				// 匹配区域标识
				if(StringUtils.equals(regionMark, planProductInfo.getRegionMark())) {
					// 匹配上区域标识
					matchInfo.append("区域标识标识匹配成功\n");
					// 记录匹配上的结构id+尺寸编码 add by huangsongbo 2018.1.6 ->start
					productStructureId = planProductInfo.getGroupOrStructureId();
					planStructureRegionMark = planProductInfo.getRegionMark();
					// 记录匹配上的结构id+尺寸编码 add by huangsongbo 2018.1.6 ->end
					
					boolean flag = false;
					
					// 检测尺寸编码+布局标识是否一致
					if(StringUtils.equals(measureCode, planProductInfo.getMeasureCode())
							&& (!idNeedMatchProductSmallpoxIdentify || groundIdentify.intValue() == planProductInfo.getStructureProductSmallpoxIdentify().intValue())
							&& (!idNeedMatchProductSmallpoxIdentify || StringUtils.equals(groundIdentify, planProductInfo.getStructureProductSmallpoxIdentify()))
							&& (Utils.getIdentifyList(groundIdentify).indexOf(planProductInfo.getStructureProductSmallpoxIdentify()) != -1)
							) {
						// 此结构必须是通用结构或者关联样板房id为一件装修样板房id ->start
						StructureProduct structureProduct = structureProductService.get(planProductInfo.getGroupOrStructureId());
						if(structureProduct == null){
							flag = false;
						}else{
							if(
									(structureProduct.getTempletId() != null && designTempletId.intValue() == structureProduct.getTempletId().intValue()) ||
									(structureProduct.getIsCommon() == null && structureProduct.getIsCommon().intValue() == 1)
									) {
								flag = true;
							}
						}
						// 此结构必须是通用结构或者关联样板房id为一件装修样板房id ->start
					}else{
						
					}
					
					// 检测尺寸编码+布局标识是否一致
					if(flag) {
						matchInfo.append("尺寸编码/布局标识匹配成功,应用此结构(planStructureId:" + planStructureId + ")");
						// 应用该结构
						planStructureId = planProductInfo.getPlanGroupId();
					}else {
						// 带自身的尺寸编码+planProductInfoMatched的款式+planProductInfoMatched的structure_number去系统中搜索
						matchInfo.append("尺寸编码/布局标识匹配失败,去系统中搜索结构\n");
						planProductInfoListMatched = this.selectOneStructureAndMatchProduct(
								measureCode, planProductInfo.getGroupOrStructureId(), planStructureProudctListMap.get(planProductInfo.getPlanGroupId()), productListmap,
								regionMark, ProductModelConstant.PRODUCTATTRCODE_DIM, groundIdentify, designTempletId
								);
						if(planProductInfoListMatched == null) {
							matchInfo.append("没有搜索到符合条件的结构\n");
						}else {
							matchInfo.append("搜索到符合条件的结构\n");
							try {
								matchInfo.append("structureId:" + planProductInfoListMatched.get(0).getPlanGroupId());
							}catch (Exception e) {
								
							}
						}
						return planProductInfoListMatched;
						if(Lists.isNotEmpty(planProductInfoListMatched)){
							productStructureId = planProductInfoListMatched.get(0).getGroupOrStructureId();
							if(productStructureId == null){
								try{
									productStructureId = Integer.valueOf(planProductInfoListMatched.get(0).getPlanGroupId().split("_")[0]);
								}catch(Exception e){
									
								}
							}
						}
						returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PRODUCTSTRUCTUREID, productStructureId);
						returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANSTRUCTUREREGIONMARK, planStructureRegionMark);
						returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANPRODUCTINFOLISTMATCHED, planProductInfoListMatched);
						return returnMap;
					}
				}
			}
			// 第一轮正常匹配 ->end
			
			// 第二轮备用区域标识匹配 ->start
			if(StringUtils.isEmpty(planStructureId)) {
				matchInfo.append("正在执行备用区域标识匹配逻辑\n");
				// 匹配备用的区域标识
				PlanProductInfo planProductInfoMatched = this.structureMatchStandByRegionMark(regionMark, planStructureMainProudctMap);
				matchInfo.append("备用区域标识匹配成功\n");
				// 带自身的尺寸编码+planProductInfoMatched的款式去系统中搜索
				if(planProductInfoMatched != null) {
					
					// 记录匹配上的结构id+尺寸编码 add by huangsongbo 2018.1.6 ->start
					productStructureId = planProductInfoMatched.getGroupOrStructureId();
					planStructureRegionMark = planProductInfoMatched.getRegionMark();
					// 记录匹配上的结构id+尺寸编码 add by huangsongbo 2018.1.6 ->end
					
					matchInfo.append("根据匹配上的结构属性在系统中搜索结构\n");
					planProductInfoListMatched = this.selectOneStructure(templetMainPlanProductInfo.getGroupOrStructureId(), planProductInfoMatched.getGroupOrStructureId(), planStructureProudctListMap.get(planStructureId));
					planProductInfoListMatched = this.selectOneStructureAndMatchProduct(
							measureCode, planProductInfoMatched.getGroupOrStructureId(),
							planStructureProudctListMap.get(planProductInfoMatched.getPlanGroupId()), productListmap,
							regionMark, ProductModelConstant.PRODUCTATTRCODE_DIM, 
							groundIdentify,
							designTempletId
							);
					if(planProductInfoListMatched == null) {
						matchInfo.append("没有搜索到符合条件的结构\n");
					}else {
						matchInfo.append("搜索到符合条件的结构\n");
						try {
							matchInfo.append("structureId:" + planProductInfoListMatched.get(0).getPlanGroupId());
						}catch (Exception e) {
							
						}
					}
					return planProductInfoListMatched;
					if(Lists.isNotEmpty(planProductInfoListMatched)){
						productStructureId = planProductInfoListMatched.get(0).getGroupOrStructureId();
						if(productStructureId == null){
							try{
								productStructureId = Integer.valueOf(planProductInfoListMatched.get(0).getPlanGroupId().split("_")[0]);
							}catch(Exception e){
								
							}
						}
					}
					returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PRODUCTSTRUCTUREID, productStructureId);
					returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANSTRUCTUREREGIONMARK, planStructureRegionMark);
					returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANPRODUCTINFOLISTMATCHED, planProductInfoListMatched);
					return returnMap;
				}
			}
			// 第二轮备用区域标识匹配 ->end
			
			if(StringUtils.isEmpty(planStructureId)) {
				// 没有匹配上,尺寸编码+款式在系统中搜索
				matchInfo.append("区域标识匹配/备用区域标识匹配均失败\n");
				// 搜索结构(未完成)
			}else {
				// 匹配上了推荐方案中的结构
				matchInfo.append("匹配上了推荐方案中的结构(templet_plan_group_id:" + templetMainPlanProductInfo.getPlanGroupId() + ";recommended_plan_group_id:" + planStructureId + ")\n");
				planProductInfoListMatched = planStructureProudctListMap.get(planStructureId);
				// test ->start
				System.out.println(planProductInfoListMatched.get(0));
				// test ->end
			}
			
		*/}
		
		/*return planProductInfoListMatched;*/
		if(Lists.isNotEmpty(planProductInfoListMatched)){
			productStructureId = planProductInfoListMatched.get(0).getGroupOrStructureId();
			if(productStructureId == null){
				try{
					productStructureId = Integer.valueOf(planProductInfoListMatched.get(0).getPlanGroupId().split("_")[0]);
				}catch(Exception e){
					
				}
			}
		}
		returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PRODUCTSTRUCTUREID, productStructureId);
		returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANSTRUCTUREREGIONMARK, planStructureRegionMark);
		returnMap.put(Constants.STRUCTUREMATCHRETURNMAPKEY_PLANPRODUCTINFOLISTMATCHED, planProductInfoListMatched);
		return returnMap;
	}
	
	/**
	 * 设置StructureMatchInfoDTO的部分信息(delPosNameList, delStructureCenter)
	 * @param structureMatchInfoDTO
	 * @param list
	 */
	private void setSomeInfo(StructureMatchInfoDTO structureMatchInfoDTO, List<PlanProductInfo> planProductInfoList) {
		
		// 参数验证 ->start
		if(structureMatchInfoDTO == null) {
			structureMatchInfoDTO = new BedroomProductMatchDTO().new StructureMatchInfoDTO();
		}
		if(planProductInfoList == null) {
			return;
		}
		// 参数验证 ->end
		
		List<String> delPosNameList = new ArrayList<String>();
		String delStructureCenter = null;
		String delStructureRegionMark = null;
		for(PlanProductInfo planProductInfo : planProductInfoList) {
			delPosNameList.add(planProductInfo.getPosName());
			if(StringUtils.isEmpty(delStructureCenter)) {
				delStructureCenter = planProductInfo.getCenter();
			}
			if(StringUtils.isEmpty(delStructureRegionMark)) {
				delStructureRegionMark = planProductInfo.getRegionMark();
			}
		}
		
		structureMatchInfoDTO.setDelPosNameList(delPosNameList);
		structureMatchInfoDTO.setDelStructureCenter(delStructureCenter);
		structureMatchInfoDTO.setDelStructureRegionMark(delStructureRegionMark);
	}
	
	private DimMatchInfoVO getDimMatchInfoVOByPlanProductInfoList(List<PlanProductInfo> list, String regionMark) {
		String logSuffix = "function:IntelligenceDecorationServiceImpl.getDimMatchInfoVOByPlanProductInfoList -> ";
		
		// 参数验证 ->start
		if(Lists.isEmpty(list)) {
			return null;
		}
		if(StringUtils.isEmpty(regionMark)) {
			return null;
		}
		// 参数验证 ->end
		
		DimMatchInfoVO dimMatchInfoVO = new DimMatchInfoVO();
		dimMatchInfoVO.setTempletRegionMark(regionMark);
		dimMatchInfoVO.setRecommendedRegionMark(list.get(0).getRegionMark());
		String planGroupId = list.get(0).getPlanGroupId();
		if(StringUtils.isEmpty(planGroupId)) {
			logger.error(logSuffix + "StringUtils.isEmpty(planGroupId) = true");
			return null;
		}
		Integer groupProductId = null;
		try {
			groupProductId = Integer.valueOf(planGroupId.split("_")[0]);
		}catch (Exception e) {
			logger.error(logSuffix + "String转化成Integer失败;str = " + planGroupId.split("_")[0]);
		}
		StructureProduct structureProduct = structureProductService.get(groupProductId);
		if(structureProduct == null) {
			logger.error(logSuffix + "structureProduct = null;structureProductId = " + list.get(0).getGroupOrStructureId());
			return null;
		}
		dimMatchInfoVO.setRecommendedStructureCode(structureProduct.getStructureCode());
		dimMatchInfoVO.setStructureDetailInfoList(this.getStructureDetailInfoListByPlanProductInfoList(list));
		return dimMatchInfoVO;
	}
	
	/**
	 * 遍历smallTypemapInfoMap检查smallTypeValuekeyInit,取出smallTypeValuekeyInit与smallTypeValuekey匹配的PlanProductInfo
	 * 使用范围:不按小类匹配,按其他属性匹配(initProductSmallTypeKey,区域标识,尺寸编码等等)
	 * 
	 * @author huangsongbo
	 * @param smallTypeValuekey 从smallTypemapInfo中取小类为smallTypeValuekey的PlanProductInfo
	 * @param planProductInfoCheck 验证附加属性(比如产品长宽高)
	 * @param isMatchMatched 是否匹配已经匹配过的产品 true:匹配过的也可以匹配;false:不匹配已经匹配过的产品
	 * @param wallorientation 
	 * @param smallTypemapInfo
	 * @return
	 */
	private PlanProductInfo checkDataFromMap(
			PlanProductInfo planProductInfoCheck, List<PlanProductInfo> recommendedPlanProductInfoList, 
			boolean isMatchMatched, checkDataFromMapEnum type
			) {
		
		if(recommendedPlanProductInfoList == null) {
			// 参数验证 ->start
			logger.error("------function:IntelligenceDecorationServiceImpl.checkDataFromMap(...) ->\n"
					+ "param:smallTypemapInfoMap = null");
			return null;
		}
		if(type == null) {
			type = checkDataFromMapEnum.defaultType;
		}
		// 参数验证 ->end
		
		for(PlanProductInfo planProductInfo : recommendedPlanProductInfoList) {
			if(type == checkDataFromMapEnum.defaultType) {
				boolean flag = this.productMatchCheckMoreInfo(planProductInfo, planProductInfoCheck);
				if(!isMatchMatched) {
					// 不匹配已经匹配过的产品
					if(planProductInfo.isMatched()) {
						flag = false;
					}
				}
				if(flag) {
					return planProductInfo;
				}
			}else {
				// 方便扩展
			}
		}
		
		return null;
	}
	
	private DimMatchInfoVO getDimMatchInfoVO(String templetRegionMark, String recommendedRegionMark) {
		// 参数验证 ->start
		if(StringUtils.isEmpty(templetRegionMark)) {
			return null;
		}
		if(StringUtils.isEmpty(recommendedRegionMark)) {
			return null;
		}
		// 参数验证 ->end
		
		DimMatchInfoVO dimMatchInfoVO = new DimMatchInfoVO();
		dimMatchInfoVO.setTempletRegionMark(templetRegionMark);
		dimMatchInfoVO.setRecommendedRegionMark(recommendedRegionMark);
		return dimMatchInfoVO;
	}
	
	private PlanProductInfo structureMatchStandByRegionMark(String regionMark,
			List<PlanProductInfo> recommendedPlanProductInfoList) {
		// 参数验证 ->start
		if(StringUtils.isEmpty(regionMark)) {
			return null;
		}
		if(recommendedPlanProductInfoList == null) {
			return null;
		}
		// 参数验证 ->end
		
		PlanProductInfo planProductInfo = null;
		if(regionMark.startsWith("1")) {
			// 识别为主地面只和1%的匹配
			planProductInfo = this.structureMatchStandByRegionMarkSon(recommendedPlanProductInfoList, "1");
		}else {
			// 优先级先匹配自身开头%的,再非1%的,匹配不到再匹配1%
			planProductInfo = this.structureMatchStandByRegionMarkSon(recommendedPlanProductInfoList, regionMark.substring(0, 1));
			if(planProductInfo == null) {
				planProductInfo = this.structureMatchStandByRegionMarkSon(recommendedPlanProductInfoList, "!1");
				if(planProductInfo == null) {
					planProductInfo = this.structureMatchStandByRegionMarkSon(recommendedPlanProductInfoList, "1");
				}
			}
		}
		return planProductInfo;
	}
	
	/**
	 * 设置背景墙长高范围匹配条件
	 * 
	 * @author huangsongbo
	 * @param planProductInfoParam
	 * @param planProductInfoParam 
	 * @param range +-范围
	 */
	private void setBeijingMatchParams(PlanProductInfo planProductInfo, PlanProductInfo planProductInfoParam, Integer range) {
		// 参数验证/处理 ->start
		if(planProductInfo == null) {
			return;
		}
		if(planProductInfoParam == null) {
			return;
		}
		if(range == null) {
			range = beijingRange;
		}
		// 参数验证/处理 ->end
		
		int fullPaveLength = 0;
		try {
			fullPaveLength = planProductInfo.getFullPaveLength() == null ? 0 : Integer.parseInt(planProductInfo.getFullPaveLength());
		}catch (Exception e) {
			fullPaveLength = 0;
		}
		
		if(fullPaveLength == 0) {
			try {
				fullPaveLength = Integer.parseInt(planProductInfo.getProductLength());
			}catch (Exception e) {
				fullPaveLength = 0;
			}
		}
		
		if(fullPaveLength != 0) {
			Integer productLengthStart = fullPaveLength - range;
			Integer productLengthEnd = fullPaveLength + range;
			if(StringUtils.equals("basic_cuho", planProductInfo.getSmallTypeValuekey()) || StringUtils.equals("basic_dzho", planProductInfo.getSmallTypeValuekey())) {
				if(fullPaveLength > 300) {
					productLengthStart -= 10;
					productLengthEnd += 10;
				}
			}
			planProductInfoParam.setProductLengthStart(productLengthStart);
			planProductInfoParam.setProductLengthEnd(productLengthEnd);
		}
		
	}
	
	/**
	 * 如果匹配不到产品,就去系统中搜索(取一个)
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @return
	 */
	private PlanProductInfo selectOneProduct(PlanProductInfo planProductInfo) {
		
		// *参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		// *参数验证 ->end
		
		// *设置查询条件 ->start
		BaseProductSearch baseProductSearch = baseProductService.getBaseProductSearchByPlanProductInfo(planProductInfo);
		baseProductSearch.setStart(0);
		baseProductSearch.setLimit(1);
		// *设置查询条件 ->end
		
		BaseProduct baseProductSelected = null;
		if(baseProductSearch != null) {
			
			List<BaseProduct> baseProductList = null;
			
			// update by huangsongbo 2018.6.2 优化order by ->start
			// 2018.6.2检测到sql中order by 导致sql太慢(8秒),太多的背景墙搜索导致接口太慢
			if(baseProductSearch.getOrderStyleId() != null && baseProductSearch.getStyleId() == null) {
				baseProductList = this.selectProductEasyOrderStyleId(baseProductSearch);
			}else if(baseProductSearch.getOrderSmallTypeValue() !=null && baseProductSearch.getProductSmallTypeValue() == null) {
				baseProductList = this.selectProductEasyOrderSmallTypeValue(baseProductSearch);
			}else if(baseProductSearch.getOrderProductModelNumber() != null && baseProductSearch.getOrderProductModelNumber() == null) {
				baseProductList = this.selectProductEasyOrderProductModelNumber(baseProductSearch);
			}else {
				baseProductList = baseProductService.selectProductEasy(baseProductSearch);
			}
			
			if(Lists.isNotEmpty(baseProductList)) {
				baseProductSelected = baseProductList.get(0);
			}
			// update by huangsongbo 2018.6.2 优化order by ->end
		}
		
		// BaseProduct->PlanProductInfo ->start
		return this.getBaseProductByPlanProductInfo(baseProductSelected);
		// BaseProduct->PlanProductInfo ->end
	}

	private List<BaseProduct> selectProductEasyOrderStyleId(BaseProductSearch baseProductSearch) {
		// 参数验证 ->start
		if(baseProductSearch == null) {
			return null;
		}
		
		Integer styleId = baseProductSearch.getOrderStyleId();
		
		if(styleId == null) {
			return baseProductService.selectProductEasy(baseProductSearch);
		}
		// 参数验证 ->end
		
		baseProductSearch.setStyleId(styleId);
		baseProductSearch.setOrderStyleId(null);
		List<BaseProduct> baseProductList = baseProductService.selectProductEasy(baseProductSearch);
		if(Lists.isNotEmpty(baseProductList)) {
			
		}else {
			baseProductSearch.setStyleId(null);
			baseProductList = this.selectProductEasyOrderSmallTypeValue(baseProductSearch);
		}
		return baseProductList;
	}

	private List<BaseProduct> selectProductEasyOrderSmallTypeValue(BaseProductSearch baseProductSearch) {
		// 参数验证 ->start
		if(baseProductSearch == null) {
			return null;
		}
		
		Integer productSmallTypeValue = baseProductSearch.getOrderSmallTypeValue();
		
		if(productSmallTypeValue == null) {
			return baseProductService.selectProductEasy(baseProductSearch);
		}
		// 参数验证 ->end
		
		baseProductSearch.setProductSmallTypeValue(productSmallTypeValue);
		baseProductSearch.setOrderSmallTypeValue(null);
		List<BaseProduct> baseProductList = baseProductService.selectProductEasy(baseProductSearch);
		if(Lists.isNotEmpty(baseProductList)) {
			
		}else {
			baseProductSearch.setProductSmallTypeValue(null);
			baseProductList = this.selectProductEasyOrderProductModelNumber(baseProductSearch);
		}
		return baseProductList;
	}

	private List<BaseProduct> selectProductEasyOrderProductModelNumber(BaseProductSearch baseProductSearch) {
		// 参数验证 ->start
		if(baseProductSearch == null) {
			return null;
		}
		
		String productModelNumber = baseProductSearch.getOrderProductModelNumber();
		
		if(StringUtils.isEmpty(productModelNumber)) {
			return baseProductService.selectProductEasy(baseProductSearch);
		}
		// 参数验证 ->end
		
		baseProductSearch.setProductModelNumber(productModelNumber);
		baseProductSearch.setOrderProductModelNumber(null);
		List<BaseProduct> baseProductList = baseProductService.selectProductEasy(baseProductSearch);
		if(Lists.isNotEmpty(baseProductList)) {
			
		}else {
			baseProductSearch.setProductModelNumber(null);
			baseProductList = baseProductService.selectProductEasy(baseProductSearch);
		}
		return baseProductList;
	}
	
	@Override
	public boolean productMatchCheckMoreInfo(PlanProductInfo planProductInfo, PlanProductInfo planProductInfoCheck) {
		// 天花布局标识List匹配
		if(Lists.isNotEmpty(planProductInfoCheck.getProductSmallpoxIdentifyList())) {
			if(planProductInfoCheck.getProductSmallpoxIdentifyList().indexOf(planProductInfo.getProductSmallpoxIdentify()) == -1) {
				return false;
			}
		}
		// 地面布局标识List匹配
		if(Lists.isNotEmpty(planProductInfoCheck.getStructureProductSmallpoxIdentifyList())) {
			if(planProductInfoCheck.getStructureProductSmallpoxIdentifyList().indexOf(planProductInfo.getStructureProductSmallpoxIdentify()) == -1) {
				return false;
			}
		}
		// 产品过滤属性匹配
		if(Lists.isNotEmpty(planProductInfoCheck.getProductFilterPropList())) {
			planProductInfo.setProductFilterPropList(baseProductService.getProductFilterPropList(planProductInfo.getProductId()));
			if(!Utils.isMatched(planProductInfoCheck.getProductFilterPropList(), planProductInfo.getProductFilterPropList())) {
				return false;
			}
		}
		// 多小类匹配
		if(Lists.isNotEmpty(planProductInfoCheck.getSmallTypeValueKeyList())) {
			List<String> smallTypeValueKeyList = new ArrayList<String>(planProductInfoCheck.getSmallTypeValueKeyList());
			Utils.dealWithBaimoType(smallTypeValueKeyList);
			if(smallTypeValueKeyList.indexOf(planProductInfo.getSmallTypeValuekey()) == -1) {
				return false;
			}
		}
		// 多小类匹配(initProduct)
		if(Lists.isNotEmpty(planProductInfoCheck.getSmallTypeValueKeyInitList())) {
			List<String> smallTypeValueKeyList = new ArrayList<String>(planProductInfoCheck.getSmallTypeValueKeyInitList());
			Utils.dealWithBaimoType(smallTypeValueKeyList);
			if(smallTypeValueKeyList.indexOf(planProductInfo.getSmallTypeValuekeyInit()) == -1) {
				return false;
			}
		}
		// 匹配产品高度
		if(StringUtils.isNotEmpty(planProductInfoCheck.getProductHeight())) {
			int baseProductHeight = 0;
			if(StringUtils.isEmpty(planProductInfo.getProductHeight())){
				
			}else {
				baseProductHeight = Integer.parseInt(planProductInfo.getProductHeight());
			}
			if(planProductInfoCheck.isBeijing()) {
				// 背景墙匹配
				if(StringUtils.equals("30", planProductInfoCheck.getProductHeight()) || StringUtils.equals("50", planProductInfoCheck.getProductHeight())) {
					if(!StringUtils.equals(planProductInfo.getProductHeight(), planProductInfoCheck.getProductHeight())){
						return false;
					}
				}else {
					if(StringUtils.equals(planProductInfo.getProductHeight(), planProductInfoCheck.getProductHeight()) || (baseProductHeight < 230 && baseProductHeight > 50)) {
						
					}else {
						return false;
					}
				}
			}else {
				if(!StringUtils.equals(planProductInfo.getProductHeight(), planProductInfoCheck.getProductHeight())){
					return false;
				}
			}
		}
		// 匹配产品长度
		if(StringUtils.isNotEmpty(planProductInfoCheck.getProductLength())) {
			if(!StringUtils.equals(planProductInfo.getProductLength(), planProductInfoCheck.getProductLength())){
				return false;
			}
		}
		// 匹配产品宽度
		if(StringUtils.isNotEmpty(planProductInfoCheck.getProductWidth())) {
			if(!StringUtils.equals(planProductInfo.getProductWidth(), planProductInfoCheck.getProductWidth())){
				return false;
			}
		}
		// 匹配产品长度范围
		Integer productLengthStart = planProductInfoCheck.getProductLengthStart();
		Integer productLengthEnd = planProductInfoCheck.getProductLengthEnd();
		if(productLengthStart != null && productLengthStart > 0
				&& productLengthEnd != null && productLengthEnd > 0) {
			if(StringUtils.isEmpty(planProductInfo.getProductLength())) {
				return false;
			}
			int productLength = 0;
			try {
				productLength = Integer.parseInt(planProductInfo.getProductLength());
			}catch (Exception e) {
				
			}
			
			if(!(productLength >= productLengthStart && productLength <= productLengthEnd)) {
				return false;
			}
		}
		// 匹配初始化白膜大类
		if(StringUtils.isNotEmpty(planProductInfoCheck.getBigTypeValuekeyInit())) {
			if(!StringUtils.equals(planProductInfo.getBigTypeValuekeyInit(), planProductInfoCheck.getBigTypeValuekeyInit())){
				return false;
			}
		}
		// 匹配初始化白膜小类
		if(StringUtils.isNotEmpty(planProductInfoCheck.getSmallTypeValuekeyInit())) {
			if(!StringUtils.equals(planProductInfo.getSmallTypeValuekeyInit(), planProductInfoCheck.getSmallTypeValuekeyInit())){
				return false;
			}
		}
		// 匹配大类
		if(StringUtils.isNotEmpty(planProductInfoCheck.getBigTypeValuekey())) {
			if(!StringUtils.equals(planProductInfo.getBigTypeValuekey(), planProductInfoCheck.getBigTypeValuekey())){
				return false;
			}
		}
		// 匹配小类
		if(StringUtils.isNotEmpty(planProductInfoCheck.getSmallTypeValuekey())) {
			if(!StringUtils.equals(planProductInfo.getSmallTypeValuekey(), planProductInfoCheck.getSmallTypeValuekey())){
				return false;
			}
		}
		// 区域标识
		if(StringUtils.isNotEmpty(planProductInfoCheck.getRegionMark())) {
			if(!StringUtils.equals(planProductInfo.getRegionMark(), planProductInfoCheck.getRegionMark())){
				return false;
			}
		}
		// 区域标识前缀
		if(StringUtils.isNotEmpty(planProductInfoCheck.getRegionMarkLikeStart())) {
			if(
					StringUtils.isNotEmpty(planProductInfo.getRegionMark()) 
					&& planProductInfo.getRegionMark().startsWith(planProductInfoCheck.getRegionMarkLikeStart())
					) {
				
			}else {
				return false;
			}
		}
		// 区域标识前缀过滤(not like)
		if(StringUtils.isNotEmpty(planProductInfoCheck.getRegionMarkNotLikeStart())) {
			if(
					StringUtils.isNotEmpty(planProductInfo.getRegionMark()) 
					&& !planProductInfo.getRegionMark().startsWith(planProductInfoCheck.getRegionMarkNotLikeStart())
					) {
				
			}else {
				return false;
			}
		}
		// 尺寸编码
		if(StringUtils.isNotEmpty(planProductInfoCheck.getMeasureCode())) {
			if(!StringUtils.equals(planProductInfo.getMeasureCode(), planProductInfoCheck.getMeasureCode())){
				return false;
			}
		}
		// 墙体类型
		if(StringUtils.isNotEmpty(planProductInfoCheck.getWallType())) {
			if(!StringUtils.equals(planProductInfo.getWallType(), planProductInfoCheck.getWallType())){
				return false;
			}
		}
		return true;
	}
	
	/**
	 * 淋浴房搜索
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param planProductInfoMatched
	 * @param planProductInfoParam
	 * @return
	 */
	private PlanProductInfo selectOneProductBa(PlanProductInfo planProductInfo, PlanProductInfo planProductInfoMatched, PlanProductInfo planProductInfoParam) {
		// 参数验证/处理 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(planProductInfoMatched == null) {
			return null;
		}
		if(planProductInfoParam == null) {
			planProductInfoParam = new PlanProductInfo();
		}
		// 参数验证/处理 ->end
		
		planProductInfoParam.setBigTypeValuekey(planProductInfo.getBigTypeValuekey());
		planProductInfoParam.setSmallTypeValuekey(planProductInfo.getSmallTypeValuekey().replace("basic_", ""));
		planProductInfoParam.setOrderBrandId(planProductInfoMatched.getBrandId());
		planProductInfoParam.setOrderProductModelNumber(planProductInfoMatched.getProductModelNumber());
		planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
		return planProductInfoMatched;
	}
	
	/**
	 * 剔除附墙
	 * 
	 * @author huangsongbo
	 * @param recommendedPlanProductInfoList
	 */
	private void getMainBeijingProduct(List<PlanProductInfo> recommendedPlanProductInfoList) {
		// 参数验证 ->start
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return;
		}
		// 参数验证 ->end
		
		// 剔除附墙 ->start
		for(int index = 0; index < recommendedPlanProductInfoList.size(); index ++) {
			PlanProductInfo planProductInfo = recommendedPlanProductInfoList.get(index);
			if(planProductInfo.getGroupType() != null && 1 == planProductInfo.getGroupType().intValue() 
					&& (planProductInfo.getIsMainStructureProduct() == null || 1 != planProductInfo.getIsMainStructureProduct().intValue())) {
				recommendedPlanProductInfoList.remove(index);
				index --;
				continue;
			}
			if(StringUtils.isEmpty(planProductInfo.getWallOrientation())) {
				continue;
			}
			Integer wallOrientationInteger = null;
			try {
				wallOrientationInteger = Integer.valueOf(planProductInfo.getWallOrientation());
			}catch (Exception e) {
				continue;
			}
			if(wallOrientationInteger != null) {
				if(wallOrientationInteger % 100 != 0) {
					// 附墙
					recommendedPlanProductInfoList.remove(index);
					index --;
					continue;
				}
			}
		}
		// 剔除附墙 ->end
	}
	
	/**
	 * 装配所有附墙对应主墙的posName
	 * 
	 * @author huangsongbo
	 * @param beijingDeputyPlanProductInfoList
	 * @param beijingPlanProductInfoList
	 */
	private void setMainProductInfo(List<PlanProductInfo> beijingDeputyPlanProductInfoList,
			List<PlanProductInfo> beijingPlanProductInfoList) {
		// 参数验证 ->start
		if(Lists.isEmpty(beijingDeputyPlanProductInfoList)) {
			return;
		}
		if(Lists.isEmpty(beijingPlanProductInfoList)) {
			return;
		}
		// 参数验证 ->end
		
		beijingDeputyPlanProductInfoList.forEach(planProductInfoDeputy -> {
			logger.debug("------posName:" + planProductInfoDeputy.getPosName());
			if(null != planProductInfoDeputy.getGroupType() && 1 == planProductInfoDeputy.getGroupType().intValue()) {
				beijingPlanProductInfoList.forEach(planProductInfoMain -> {
					// 应对结构背景墙 ->start
					if(
							null != planProductInfoMain 
							&& 1 == planProductInfoMain.getGroupType().intValue() 
							&& null != planProductInfoMain.getPlanGroupId() 
							&& StringUtils.equals(planProductInfoDeputy.getPlanGroupId(), planProductInfoMain.getPlanGroupId())
							&& null != planProductInfoMain.getIsMainStructureProduct()
							&& 1 == planProductInfoMain.getIsMainStructureProduct().intValue()
							) {
						planProductInfoDeputy.setMainProductPosName(planProductInfoMain.getPosName());
						return;
					}
					// 应对结构背景墙 ->end
				});
			}else {
				if(StringUtils.isEmpty(planProductInfoDeputy.getWallOrientation())) {
					return;
				}
				Integer wallOrientationDeputyInteger = null;
				try {
					wallOrientationDeputyInteger = Integer.valueOf(planProductInfoDeputy.getWallOrientation());
				}catch (Exception e) {
					return;
				}
				
				for(PlanProductInfo planProductInfoMain : beijingPlanProductInfoList) {
					// 应对主附墙(非结构背景墙) ->start
					if(StringUtils.isEmpty(planProductInfoMain.getWallOrientation())) {
						continue;
					}
					Integer wallOrientationMainInteger = null;
					try {
						wallOrientationMainInteger = Integer.valueOf(planProductInfoMain.getWallOrientation());
					}catch (Exception e) {
						continue;
					}
					if(wallOrientationDeputyInteger / 100 == wallOrientationMainInteger / 100) {
						planProductInfoDeputy.setMainProductPosName(planProductInfoMain.getPosName());
						return;
					}
					// 应对主附墙(非结构背景墙) ->end
				}
			}
		});
	}
	
	/**
	 * 获取被删除的背景墙信息
	 * 
	 * @author huangsongbo
	 * @param recommendedPlanId
	 * @return
	 * @throws IntelligenceDecorationException 
	 */
	private List<Map<deletedBeijingProductInfoMapKeyEnum, String>> getDeletedBeijingProductInfo(Integer recommendedPlanId) throws IntelligenceDecorationException {
		if(recommendedPlanId == null) {
			throw new IntelligenceDecorationException("推荐方案id不能为空");
		}
		DesignPlanRecommended designPlanRecommended = designPlanRecommendedService.get(recommendedPlanId);
		if(designPlanRecommended == null) {
			throw new IntelligenceDecorationException("推荐方案没有找到,推荐方案id:" + recommendedPlanId);
		}
		
		// 返回结果
		Integer designTempletId = designPlanRecommended.getDesignTemplateId();
		
		// 获取样板房中所有背景墙信息
		List<DesignTempletProduct> beijingDesignTempletProductList = designTempletProductService.getBeijingProductInfo(designTempletId);
		List<Map<deletedBeijingProductInfoMapKeyEnum, String>> beijingDesignTempletProductMapList= new ArrayList<Map<deletedBeijingProductInfoMapKeyEnum,String>>();
		if(Lists.isNotEmpty(beijingDesignTempletProductList)) {
			for(DesignTempletProduct designTempletProduct : beijingDesignTempletProductList) {
				Map<deletedBeijingProductInfoMapKeyEnum, String> designTempletProductMap = new HashMap<IntelligenceDecorationServiceImpl.deletedBeijingProductInfoMapKeyEnum, String>();
				designTempletProductMap.put(deletedBeijingProductInfoMapKeyEnum.groupType, designTempletProduct.getGroupType() + "");
				designTempletProductMap.put(deletedBeijingProductInfoMapKeyEnum.isMainStructureProduct, designTempletProduct.getIsMainStructureProduct() + "");
				designTempletProductMap.put(deletedBeijingProductInfoMapKeyEnum.wallOrientation, designTempletProduct.getWallOrientation());
				designTempletProductMap.put(deletedBeijingProductInfoMapKeyEnum.wallType, designTempletProduct.getWallType());
				beijingDesignTempletProductMapList.add(designTempletProductMap);
			}
		}
		
		// 获取推荐方案中所有背景墙信息
		List<DesignPlanRecommendedProduct> beijingDesignPlanRecommendedProductList = designPlanRecommendedProductService.getBeijingProductInfo(recommendedPlanId);
		List<Map<deletedBeijingProductInfoMapKeyEnum, String>> beijingDesignPlanRecommendedProductMapList= new ArrayList<Map<deletedBeijingProductInfoMapKeyEnum,String>>();
		if(Lists.isNotEmpty(beijingDesignPlanRecommendedProductList)) {
			for(DesignPlanRecommendedProduct designPlanRecommendedProduct : beijingDesignPlanRecommendedProductList) {
				Map<deletedBeijingProductInfoMapKeyEnum, String> designPlanRecommendedProductMap = new HashMap<IntelligenceDecorationServiceImpl.deletedBeijingProductInfoMapKeyEnum, String>();
				designPlanRecommendedProductMap.put(deletedBeijingProductInfoMapKeyEnum.groupType, designPlanRecommendedProduct.getGroupType() + "");
				designPlanRecommendedProductMap.put(deletedBeijingProductInfoMapKeyEnum.isMainStructureProduct, designPlanRecommendedProduct.getIsMainStructureProduct() + "");
				designPlanRecommendedProductMap.put(deletedBeijingProductInfoMapKeyEnum.wallOrientation, designPlanRecommendedProduct.getWallOrientation());
				designPlanRecommendedProductMap.put(deletedBeijingProductInfoMapKeyEnum.wallType, designPlanRecommendedProduct.getWallType());
				beijingDesignPlanRecommendedProductMapList.add(designPlanRecommendedProductMap);
			}
		}
		// 处理出被删除的样板房信息
		beijingDesignTempletProductMapList.removeAll(beijingDesignPlanRecommendedProductMapList);
		
		// 剔除非主墙背景墙(结构背景墙非主墙+附墙) ->start
		for (int index = 0; index < beijingDesignTempletProductMapList.size(); index++) {
			Map<deletedBeijingProductInfoMapKeyEnum, String> deletedBeijingProductInfoMap = beijingDesignTempletProductMapList.get(index);
			if(deletedBeijingProductInfoMap == null) {
				beijingDesignTempletProductMapList.remove(index);
				index --;
				continue;
			}
			// 踢除附墙 ->start
			String wallOrientation = deletedBeijingProductInfoMap.get(deletedBeijingProductInfoMapKeyEnum.wallOrientation);
			Integer wallOrientationInteger = null;
			try {
				wallOrientationInteger = Integer.valueOf(wallOrientation.trim());
			}catch (Exception e) {
				throw new IntelligenceDecorationException("样板房中某个背景墙的墙体方位数据异常:wallOrientation:" + wallOrientation);
			}
			if(wallOrientationInteger == null) {
				throw new IntelligenceDecorationException("样板房中某个背景墙的墙体方位数据异常:wallOrientation:" + wallOrientation);
			}
			if(wallOrientationInteger % 100 != 0) {
				// 附墙
				beijingDesignTempletProductMapList.remove(index);
				index --;
				continue;
			}
			// 踢除附墙 ->end
			// 提出结构背景墙非主墙 ->start
			String groupType = deletedBeijingProductInfoMap.get(deletedBeijingProductInfoMapKeyEnum.groupType);
			String isMainStructureProduct = deletedBeijingProductInfoMap.get(deletedBeijingProductInfoMapKeyEnum.isMainStructureProduct);
			if(StringUtils.equals("1", groupType) && !StringUtils.equals("1", isMainStructureProduct)) {
				beijingDesignTempletProductMapList.remove(index);
				index --;
				continue;
			}
			// 提出结构背景墙非主墙 ->end
		}
		// 剔除非主墙背景墙(结构背景墙非主墙+附墙) ->end
		return beijingDesignTempletProductMapList;
	}
	
	/**
	 * 统计推荐方案中被删除的背景墙数量
	 * 得到一个Map<String, Integer>,意义为:1(餐厅墙)类型的背景墙,被删除了多少个
	 * 
	 * @author huangsongbo
	 * @param deletedBeijingProductInfoList 
	 * @param beijingTypePriorityConfMap
	 * @return
	 */
	private Map<String, Integer> getDeleteNumInfoRecommendedMap(
			List<Map<deletedBeijingProductInfoMapKeyEnum, String>> deletedBeijingProductInfoList,
			Map<String, String> beijingTypePriorityConfMap) {
		String logPrefix = "function:IntelligenceDecorationServiceImpl.getDeleteNumInfoRecommendedMap -> ";
		
		// 参数验证 ->start
		if(deletedBeijingProductInfoList == null) {
			return null;
		}
		if(beijingTypePriorityConfMap == null) {
			logger.error(logPrefix + "beijingTypePriorityConfMap = null");
			return null;
		}
		// 参数验证 ->end
		
		Map<String, Integer> returnMap = new HashMap<String, Integer>();
		
		for(Map<deletedBeijingProductInfoMapKeyEnum, String> deletedBeijingProductInfo : deletedBeijingProductInfoList) {
			String wallType = deletedBeijingProductInfo.get(deletedBeijingProductInfoMapKeyEnum.wallType);
			String key = beijingTypePriorityConfMap.get(wallType);
			if(StringUtils.isEmpty(key)) {
				key = "-1";
			}
			Integer deletedNum = returnMap.get(key);
			if(deletedNum == null) {
				returnMap.put(key, 1);
			}else {
				returnMap.put(key, deletedNum ++);
			}
		}
		return returnMap;
	}
	
	/**
	 * 统计该样板房,需要删除多少个大类下的背景墙
	 * returnMap:key;对应大类key;value:需要删除背景墙个数
	 * 
	 * @author huangsongbo
	 * @param planProductInfoMapTempletBeijing
	 * @param planProductInfoMapRecommendedBeijing
	 * @param deleteNumInfoRecommendedMap
	 * @return
	 */
	private Map<String, Integer> getDeleteNumInfoMapV2(
			Map<String, List<PlanProductInfo>> planProductInfoMapTempletBeijing,
			Map<String, List<PlanProductInfo>> planProductInfoMapRecommendedBeijing,
			Map<String, Integer> deleteNumInfoRecommendedMap) {
		String logPrefix = "function:IntelligenceDecorationServiceImpl.getDeleteNumInfoMapV2 -> ";
		// 参数验证 ->start
		if(planProductInfoMapTempletBeijing == null) {
			logger.error(logPrefix + "planProductInfoMapTempletBeijing = null");
			return null;
		}
		if(planProductInfoMapRecommendedBeijing == null) {
			logger.error(logPrefix + "planProductInfoMapRecommendedBeijing = null");
			return null;
		}
		if(deleteNumInfoRecommendedMap == null) {
			logger.error(logPrefix + "deleteNumInfoRecommendedMap = null");
			return null;
		}
		// 参数验证 ->end
		
		Map<String, Integer> returnMap = new HashMap<String, Integer>();
		for(Entry<String, Integer> entry : deleteNumInfoRecommendedMap.entrySet()) {
			String key = entry.getKey();
			Integer value = entry.getValue();
			if(value.intValue() > 0) {
				// 此情况下,样板房该大类下的背景墙数量和推荐方案中该大类下的背景墙数量保持一致
				// 获取推荐方案该大类下的背景墙数量 ->start
				int recommendedBeijingNum = 0;
				List<PlanProductInfo> planProductInfoRecommendedList = planProductInfoMapRecommendedBeijing.get(key);
				if(Lists.isNotEmpty(planProductInfoRecommendedList)) {
					recommendedBeijingNum = planProductInfoRecommendedList.size();
				}
				// 获取推荐方案该大类下的背景墙数量 ->end
				
				// 获取样板房中该大类下的背景墙数量 ->start
				int templetBeijingNum = 0;
				List<PlanProductInfo> planProductInfoTempletList = planProductInfoMapTempletBeijing.get(key);
				if(Lists.isNotEmpty(planProductInfoTempletList)) {
					templetBeijingNum = planProductInfoTempletList.size();
				}
				if(templetBeijingNum > recommendedBeijingNum) {
					returnMap.put(key, templetBeijingNum - recommendedBeijingNum);
				}
				// 获取样板房中该大类下的背景墙数量 ->end
			}
		}
		return returnMap;
	}
	
	/**
	 * 统计样板房中的背景墙
	 * 统计称大类key对应样板房背景墙信息的map
	 * 
	 * @author huangsongbo
	 * @param beijingPlanProductInfoList
	 * @param beijingTypePriorityConfMap
	 * @return
	 */
	private Map<String, List<PlanProductInfo>> getPlanProductInfoMapTempletBeijing(
			List<PlanProductInfo> beijingPlanProductInfoList, Map<String, String> beijingTypePriorityConfMap) {
		String logPrefix = "function:IntelligenceDecorationServiceImpl.getPlanProductInfoMapTempletBeijing -> ";
		
		// 参数验证 ->start
		if(Lists.isEmpty(beijingPlanProductInfoList)) {
			return null;
		}
		if(beijingTypePriorityConfMap == null) {
			logger.error(logPrefix + "beijingTypePriorityConfMap = null");
			return null;
		}
		// 参数验证 ->end
		
		Map<String, List<PlanProductInfo>> returnMap = new HashMap<String, List<PlanProductInfo>>();
		for(PlanProductInfo planProductInfo : beijingPlanProductInfoList) {
			String wallType = planProductInfo.getWallType();
			String key = beijingTypePriorityConfMap.get(wallType) == null ? -1 + "" : beijingTypePriorityConfMap.get(wallType);
			if(!returnMap.containsKey(key)) {
				List<PlanProductInfo> planProductInfoList = new ArrayList<PlanProductInfo>();
				planProductInfoList.add(planProductInfo);
				returnMap.put(key, planProductInfoList);
			}else {
				List<PlanProductInfo> planProductInfoList = returnMap.get(key);
				if(Lists.isEmpty(planProductInfoList)) {
					planProductInfoList = new ArrayList<PlanProductInfo>();
					planProductInfoList.add(planProductInfo);
					returnMap.put(key, planProductInfoList);
				}else {
					planProductInfoList.add(planProductInfo);
				}
			}
		}
		return returnMap;
	}
	
	/**
	 * 删除样板房背景墙逻辑
	 * 
	 * @author huangsongbo
	 * @param planProductInfoMapTempletBeijing
	 * @param planProductInfoMapRecommendedBeijing
	 * @param deleteNumInfoMap
	 */
	private void deleteTempletBeijingProductV2(Map<String, List<PlanProductInfo>> planProductInfoMapTempletBeijing,
			Map<String, List<PlanProductInfo>> planProductInfoMapRecommendedBeijing,
			Map<String, Integer> deleteNumInfoMap) {
		/*String logPrefix = "function:IntelligenceDecorationServiceImpl.deleteTempletBeijingProductV2 -> ";*/
		
		// 参数验证 ->start
		if(planProductInfoMapTempletBeijing == null) {
			return;
		}
		if(planProductInfoMapRecommendedBeijing == null) {
			return;
		}
		if(deleteNumInfoMap == null) {
			return;
		}
		// 参数验证 ->end
		
		// 统计推荐方案中背景墙类别
		Map<String, List<String>> wallTypeStatisticsRecommendedMap = this.getWallTypeStatisticsRecommendedMap(planProductInfoMapRecommendedBeijing);
		
		for(Entry<String, Integer> entry : deleteNumInfoMap.entrySet()) {
			String key = entry.getKey();
			Integer num = entry.getValue();
			
			if(num < 1) {
				continue;
			}
			
			// 推荐方案key类型的背景墙类型List
			List<String> wallTypeRecommendedList = wallTypeStatisticsRecommendedMap.get(key);
			
			// 第一轮删除(优先删除...;举例:假设样板房中背景墙有A,B,C类背景墙,推荐方案有A,B,优先删除C类背景墙) ->start
			List<PlanProductInfo> planProductInfoTempletList = planProductInfoMapTempletBeijing.get(key);
			for(PlanProductInfo planProductInfo : planProductInfoTempletList) {
				String wallType = planProductInfo.getWallType();
				if(wallTypeRecommendedList == null || wallTypeRecommendedList.indexOf(wallType) == -1) {
					planProductInfo.setNeedBeMatched(false);
					num --;
				}
				if(num.intValue() == 0) {
					break;
				}
			}
			// 第一轮删除(优先删除...;举例:假设样板房中背景墙有A,B,C类背景墙,推荐方案有A,B,优先删除C类背景墙) ->end
			
			// 第二轮删除(删除数量不够,同类型背景墙来凑) ->start
			if(num.intValue() == 0) {
				continue;
			}
			for(PlanProductInfo planProductInfo : planProductInfoTempletList) {
				if(!planProductInfo.isNeedBeMatched()) {
					continue;
				}
				planProductInfo.setNeedBeMatched(false);
				num --;
				if(num.intValue() == 0) {
					break;
				}
			}
			// 第二轮删除(删除数量不够,同类型背景墙来凑) ->end
		}
	}
	
	/**
	 * 得到背景墙的value
	 * @return
	 */
	private List<Integer> getBeijingValueList() {
		if(beijingValueList == null) {
			if(Lists.isEmpty(beijingValuekeyList)) {
				return null;
			}else {
				beijingValueList = sysDictionaryService.getValueByTypeAndValueKeylist(ProductTypeConstant.PRODUCT_BIG_TYPE_QIANGM, beijingValuekeyList);
				if(Lists.isEmpty(beijingValueList)) {
					beijingValueList = null;
				}else {
					
				}
			}
		}else {
			
		}
		return beijingValueList;
	}
	
	/**
	 * 搜索长度最接近的背景墙
	 * 
	 * @author huangsongbo
	 * @param planProductInfoParam
	 * @param productLength
	 * @return
	 */
	private PlanProductInfo selectOneProductNoBeijingProduct(PlanProductInfo planProductInfoParam,
			String productLength) {
		String logPrefixFunction = logPrefixClass + "selectOneProductNoBeijingProduct -> ";
		
		// 参数验证 ->start
		if(StringUtils.isEmpty(productLength)) {
			logger.error(logPrefixFunction + "StringUtils.isEmpty(productLength) = true");
			return null;
		}
		if(planProductInfoParam == null) {
			logger.error(logPrefixFunction + "planProductInfoParam = null");
			return null;
		}
		// 参数验证 ->end
		
		planProductInfoParam.setProductLengthStart(null);
		planProductInfoParam.setProductLengthEnd(null);
		try {
			planProductInfoParam.setOrderAbsProuductLength(Integer.valueOf(productLength));
		}catch (Exception e) {
			logger.error(logPrefixFunction + "String -> Integer failed;String = " + productLength);
			return null;
		}
		return this.selectOneProduct(planProductInfoParam);
	}
	
	/**
	 * 背景墙匹配新逻辑
	 * 背景墙匹配逻辑需求修改(2018.3.8)
	 * 例如有背景墙墙体分类优先级依次是:1,2,3,4
	 * eg:优先级4的,最优匹配3,其次2..类推
	 * eg:优先级1的,最先匹配4,其次是3
	 * 可以想象成是一个环
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param recommendedPlanProductInfoList
	 * @return
	 * @throws IntelligenceDecorationException 
	 */
	private PlanProductInfo productListMatchBeijingQiangmScoreV2(PlanProductInfo planProductInfo,
			List<PlanProductInfo> recommendedPlanProductInfoList) throws IntelligenceDecorationException {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return null;
		}
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return null;
		}
		// 参数验证 ->end
		
		// 整理wallTypeSorce(背景墙分类优先级) ->start
		List<String> wallTypeList = Utils.getWallTypeList();
		if(Lists.isEmpty(wallTypeList)) {
			throw new IntelligenceDecorationException(IntelligenceDecorationExceptionEnum.matchFailed.getMessage());
		}
		List<PlanProductInfo> planProductInfoList = new ArrayList<ProductListByTypeInfo.PlanProductInfo>();
		recommendedPlanProductInfoList.forEach(item -> {
				item.setWallTypeScore(wallTypeList.indexOf(item.getWallType()));
				planProductInfoList.add(item);
			});
		planProductInfo.setWallTypeScore(wallTypeList.indexOf(planProductInfo.getWallType()));
		planProductInfoList.add(planProductInfo);
		// 整理wallTypeSorce(背景墙分类优先级) ->end
		
		// 排序优先级 ->start
		Collections.sort(planProductInfoList, new Comparator<PlanProductInfo>() {
			
			@Override
			public int compare(PlanProductInfo planProductInfo1, PlanProductInfo planProductInfo2) {
				return planProductInfo1.getWallTypeScore() - planProductInfo2.getWallTypeScore();
			}
			
		});
		// 排序优先级 ->end
		
		// 按需求定制的逻辑取出最优选择的背景墙(具体逻辑见方法注释) ->start
		Integer index = planProductInfoList.indexOf(planProductInfo);
		if(index.intValue() == -1 || index.intValue() == 0) {
			return planProductInfoList.get(planProductInfoList.size() - 1);
		}else {
			return planProductInfoList.get(index - 1);
		}
		// 按需求定制的逻辑取出最优选择的背景墙(具体逻辑见方法注释) ->end
	}
	
	/**
	 * 匹配系列产品,获得一个匹配结果集
	 * 
	 * @author huangsongbo
	 * @param seriesProductInfoMap
	 * @param productListmap
	 * @return
	 */
	private Map<String, PlanProductInfo> getSeriesMatchInfoMap(Map<String, List<PlanProductInfo>> seriesProductInfoMap,
			Map<String, List<PlanProductInfo>> productListmap) {
		Map<String, PlanProductInfo> returnMap = new HashMap<String, ProductListByTypeInfo.PlanProductInfo>();
		// 参数验证/处理 ->start
		if(seriesProductInfoMap == null) {
			return returnMap;
		}
		if(productListmap == null) {
			return returnMap;
		}
		// 参数验证/处理 ->end
		
		for(String key : seriesProductInfoMap.keySet()) {
			List<PlanProductInfo> templetPlanProductInfoList = seriesProductInfoMap.get(key);
			if(Lists.isNotEmpty(templetPlanProductInfoList)) {
				for(PlanProductInfo templetPlanProductInfo : templetPlanProductInfoList) {
					// 匹配参数设置 ->start
					PlanProductInfo planProductInfoParam = new PlanProductInfo();
					planProductInfoParam.setBigTypeValuekey(templetPlanProductInfo.getBigTypeValuekey());
					planProductInfoParam.setSmallTypeValuekey(templetPlanProductInfo.getSmallTypeValuekey().replace("basic_", ""));
					// 匹配参数设置 ->end
					
					PlanProductInfo planProductInfoMatched = this.checkDataFromMap
							(planProductInfoParam, productListmap.get(templetPlanProductInfo.getBigTypeValuekey()), true, checkDataFromMapEnum.defaultType);
					if(planProductInfoMatched == null) {
						
					}else {
						returnMap.put(key, planProductInfoMatched);
						break;
					}
				}
			}
		}
		return returnMap;
	}
	
	/**
	 * 系列匹配
	 * 根据匹配到的产品自行搜索
	 * 
	 * @author huangsongbo
	 * @param templetPlanProductInfo
	 * @param planProductInfo
	 * @param matchInfo 
	 * @return
	 * @throws IntelligenceDecorationException 
	 */
	private PlanProductInfo getProductMatchInfoDTOSeries(PlanProductInfo templetPlanProductInfo,
			PlanProductInfo planProductInfo, StringBuffer matchInfo) throws IntelligenceDecorationException {
		// 参数验证/处理 ->start
		if(templetPlanProductInfo == null) {
			return null;
		}
		if(planProductInfo == null) {
			return null;
		}
		if(matchInfo == null) {
			matchInfo = new StringBuffer();
		}
		// 参数验证/处理 ->end
		
		Integer seriesId = planProductInfo.getSeriesId();
		if(seriesId == null || 0 == seriesId.intValue()) {
			throw new IntelligenceDecorationException("推荐方案中,产品" + planProductInfo.getProductCode() + "需要录系列属性");
		}
		
		PlanProductInfo planProductInfoParam = new PlanProductInfo();
		planProductInfoParam.setBigTypeValuekey(templetPlanProductInfo.getBigTypeValuekey());
		/*planProductInfoParam.setSmallTypeValuekey(templetPlanProductInfo.getSmallTypeValuekey().replace("basic_", ""));*/
		planProductInfoParam.setOrderSmallTypeValueKey(templetPlanProductInfo.getSmallTypeValuekey().replace("basic_", ""));
		/*planProductInfoParam.setSmallTypeValueList(baseProductService.getsmallTypeValueListBySmallTypeValueKey(templetPlanProductInfo.getSmallTypeValuekey().replace("basic_", "")));*/
		this.setSmallTypeListParam(planProductInfoParam, templetPlanProductInfo.getSmallTypeValuekey());
		planProductInfoParam.setSeriesId(seriesId);
		Map<String,String> stretchMap = baseProductService.getStretchZoomLength(templetPlanProductInfo.getSmallTypeValuekey());
		if (stretchMap != null && stretchMap.size() > 0) {
			int stretchLength = Utils.getIntValue(stretchMap.get(ProductModelConstant.STRETCH_LENGTH));
			this.setBeijingMatchParams(templetPlanProductInfo, planProductInfoParam, stretchLength);
		} else {
			/*planProductInfoParam.setProductLength(templetPlanProductInfo.getFullPaveLength());*/
		}
		matchInfo.append("搜索条件:seriesId:" + seriesId);
		// 设置属性过滤条件
		planProductInfoParam.setProductFilterPropList(baseProductService.getProductFilterPropList(templetPlanProductInfo.getProductId()));
		PlanProductInfo planProductInfoMatched = this.selectOneProduct(planProductInfoParam);
		// 材质匹配 add by huangsongbo 2017.12.28 ->start
		if(planProductInfoMatched != null && planProductInfo != null){
			String splitTexturesInfo = designPlanProductService.matchSplitTexturesInfo(planProductInfoMatched.getSplitTexturesChooseInfo(), planProductInfo.getProductId(), planProductInfo.getSplitTexturesChooseInfo());
			planProductInfoMatched.setSplitTexturesChooseInfo(splitTexturesInfo);
		}
		// 材质匹配 add by huangsongbo 2017.12.28 ->end
		return planProductInfoMatched;
	}
	
	/**
	 * 墙面结构的搜索
	 * 
	 * @author huangsongbo
	 * @param groupOrStructureId 匹配到的墙面结构id
	 * @param designTempletId 
	 * @param planProductInfoRecommendedList 推荐方案中该结构的明细
	 * @param productListmap
	 * @param matchInfo 匹配信息
	 * @return
	 */
	private List<PlanProductInfo> selectOneStructureAndMatchProductForQiangm(Integer groupOrStructureId,
		List<PlanProductInfo> planProductInfoRecommendedList, Map<String, List<PlanProductInfo>> productListmap, Integer designTempletId, StringBuffer matchInfo) {
		List<PlanProductInfo> planProductInfoList = this.selectOneStructureForQiangm(groupOrStructureId, designTempletId, matchInfo);
		// 结构的白膜明细匹配对应材质产品
		return this.matchStructureProduct(planProductInfoList, planProductInfoRecommendedList, productListmap, ProductModelConstant.PRODUCTATTRCODE_QIANGM);
	}
	
	private List<StructureDetailInfoVO> getStructureDetailInfoListByPlanProductInfoList(List<PlanProductInfo> list) {
		String logSuffix = "function:IntelligenceDecorationServiceImpl.getStructureDetailInfoListByPlanProductInfoList -> ";
		
		// 参数验证/处理 ->start
		if(Lists.isEmpty(list)) {
			logger.error(logSuffix + "list = null");
			return null;
		}
		// 参数验证/处理 ->end
		List<StructureDetailInfoVO> structureDetailInfoVOList = new ArrayList<StructureDetailInfoVO>();
		for(PlanProductInfo planProductInfo : list) {
			StructureDetailInfoVO structureDetailInfoVO = new StructureDetailInfoVO();
			structureDetailInfoVO.setStructureSign(productPropsService.getStructureProductPropCodeByProductId(planProductInfo.getInitProductId(), ProductPropsConstant.PRODUCTPROPS_CODE_STRUCTURESIGN));
			BaseProduct baseProduct = baseProductService.get(planProductInfo.getProductId());
			if(baseProduct != null) {
				structureDetailInfoVO.setProductId(baseProduct.getId());
				structureDetailInfoVO.setProductCode(baseProduct.getProductCode());
				structureDetailInfoVO.setSplitTexturesChooseInfo(this.getSplitTexturesChooseInfoByPlanProductInfo(baseProduct));
			}
			structureDetailInfoVOList.add(structureDetailInfoVO);
		}
		return structureDetailInfoVOList;
	}
	
	private PlanProductInfo structureMatchStandByRegionMarkSon(List<PlanProductInfo> recommendedPlanProductInfoList,
			String str) {		// 参数验证 ->start
		if(StringUtils.isEmpty(str)) {
			return null;
		}
		if(Lists.isEmpty(recommendedPlanProductInfoList)) {
			return null;
		}
		// 参数验证 ->end
		
		for(PlanProductInfo planProductInfo : recommendedPlanProductInfoList) {
			String measureCode = planProductInfo.getMeasureCode();
			if(StringUtils.isNotEmpty(measureCode)) {
				if(str.startsWith("!")) {
					if(!measureCode.startsWith(str.substring(1))) {
						return planProductInfo;
					}
				}else {
					if(measureCode.startsWith(str)) {
						return planProductInfo;
					}
				}
			}
		}
		return null;
	}
	
	/**
	 * BaseProduct ->PlanProductInfo
	 * 
	 * @author huangsongbo
	 * @param baseProductSelected
	 * @return
	 */
	private PlanProductInfo getBaseProductByPlanProductInfo(BaseProduct baseProduct) {
		
		// *参数验证 ->start
		if(baseProduct == null) {
			return null;
		}
		// *参数验证 ->end
		
		PlanProductInfo planProductInfo = new PlanProductInfo();
		planProductInfo.setProductId(baseProduct.getId());
		planProductInfo.setBigTypeValuekey(baseProduct.getBigTypeValueKey());
		planProductInfo.setSmallTypeValuekey(baseProduct.getSmallTypeValueKey());
		planProductInfo.setProductCode(baseProduct.getProductCode());
		planProductInfo.setProductLength(baseProduct.getProductLength());
		planProductInfo.setProductWidth(baseProduct.getProductWidth());
		planProductInfo.setProductHeight(baseProduct.getProductHeight());
		planProductInfo.setFullPaveLength(baseProduct.getFullPaveLength());
		planProductInfo.setMeasureCode(baseProduct.getMeasureCode());
		planProductInfo.setSplitTexturesChooseInfo(baseProduct.getSplitTexturesInfo());
		planProductInfo.setStyleId(baseProduct.getStyleId());
		return planProductInfo;
	}
	
	private Map<String, List<String>> getWallTypeStatisticsRecommendedMap(
			Map<String, List<PlanProductInfo>> planProductInfoMapRecommendedBeijing) {
		// 参数验证 ->start
		if(planProductInfoMapRecommendedBeijing == null) {
			return null;
		}
		// 参数验证 ->end
		
		Map<String, List<String>> returnMap = new HashMap<String, List<String>>();
		for(Entry<String, List<PlanProductInfo>> entry : planProductInfoMapRecommendedBeijing.entrySet()) {
			String key = entry.getKey();
			List<PlanProductInfo> planProductInfoList = entry.getValue();
			if(Lists.isEmpty(planProductInfoList)) {
				continue;
			}
			List<String> wallTypelist = new ArrayList<String>();
			planProductInfoList.forEach(planProductInfo -> {
				wallTypelist.add(planProductInfo.getWallType());
			});
			returnMap.put(key, wallTypelist);
		}
		return returnMap;
	}
	
	/**
	 * 设置小类list查询条件 in/not in
	 * 
	 * @author huangsongbo
	 * @param planProductInfoParam
	 * @param smallTypeValuekey
	 */
	@SuppressWarnings("unchecked")
	private void setSmallTypeListParam(PlanProductInfo planProductInfoParam, String smallTypeValuekey) {
		// 参数验证/处理 ->start
		if(planProductInfoParam == null) {
			return;
		}
		if(StringUtils.isEmpty(smallTypeValuekey)) {
			return;
		}
		smallTypeValuekey = smallTypeValuekey.replace("basic_", "");
		// 参数验证/处理 ->end
		/*Map<getsmallTypeValueListBySmallTypeValueKeyMapKeyEnum, List<Integer>> smallTypeListProperties = baseProductService.getsmallTypeValueListBySmallTypeValueKey(smallTypeValuekey);*/
		Map<getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum, Object> smallTypeListProperties = baseProductService.getSmallTypeValueListBySmallTypeValueKey(smallTypeValuekey);
		if(smallTypeListProperties == null) {
			return;
		}
		if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in)) {
			planProductInfoParam.setSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.in));
		}else {
			if(smallTypeListProperties.containsKey(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn)) {
				planProductInfoParam.setExcludeSmallTypeValueList((List<Integer>) smallTypeListProperties.get(getSmallTypeValueListBySmallTypeValueKeyMapKeyEnum.notIn));
			}
		}
	}
	
	/**
	 * 墙面结构的搜索
	 * 
	 * @author huangsongbo
	 * @param structureId 匹配上的结构的id
	 * @param designTempletId 一件装修样板房id(用于搜索定制墙面结构)
	 * @param matchInfo 
	 * @return
	 */
	private List<PlanProductInfo> selectOneStructureForQiangm(Integer structureId, Integer designTempletId, StringBuffer matchInfo) {
		String logPrefixFunction = logPrefixClass + "selectOneStructureForQiangm -> ";
		
		// 参数验证 ->start
		if(structureId == null) {
			return null;
		}
		StructureProduct structureProduct = structureProductService.get(structureId);
		if(structureProduct == null) {
			logger.error(logPrefixFunction + "selectOneStructureForQiangm:结构没有找到,structureId:" + structureId);
			return null;
		}
		if(designTempletId == null) {
			return null;
		}
		// 参数验证 ->end

		matchInfo.append("自行搜索墙面结构\n");
		
		// 根据matchStructureId获取结构的搜索条件(styleId,structure_number) ->start
		StructureProductSearch structureProductSearch = new StructureProductSearch();
		structureProductSearch.setTempletId(designTempletId);
		structureProductSearch.setStructureType(StructureProductConstant.STRUCTURETYPE_QIAMGM);
		structureProductSearch.setStructureNumber(structureProduct.getStructureNumber());
		matchInfo.append("搜索墙面结构条件:tempetId:" + structureProductSearch.getTempletId() + 
				";structureType:" + structureProductSearch.getStructureType() + 
				";structureNumber:" + structureProductSearch.getStructureNumber());
		Integer structureIdSeleted = structureProductService.easySearchV2(structureProductSearch);
		// 根据matchStructureId获取结构的搜索条件(styleId,structure_number) ->end

		if (structureIdSeleted == null) {
			return null;
		}
		matchInfo.append("匹配上结构,structureId:" + structureIdSeleted);
		
		String planGroupId = structureIdSeleted + "_" + Utils.generateRandomDigitString(12);

		// 取出结构明细拼装成List<PlanProductInfo>
		List<PlanProductInfo> planProductInfoList = structureProductService
				.getPlanProductInfoListByStructureId(structureIdSeleted);
		// 取出结构明细的属性(用于结构白膜匹配推荐方案中的结构替换成的材质)
		for (PlanProductInfo planProductInfo : planProductInfoList) {
			planProductInfo.setBigTypeValuekeyInit(planProductInfo.getBigTypeValuekey());
			planProductInfo.setSmallTypeValuekeyInit(planProductInfo.getSmallTypeValuekey());
			planProductInfo.setInitProductId(planProductInfo.getProductId());
			planProductInfo.setMeasureCode(null);
			planProductInfo.setRegionMark(null);
			planProductInfo.setPlanGroupId(planGroupId);
			planProductInfo.setIsStandard(0);
			planProductInfo.setIsMainStructureProduct(0);
			planProductInfo.setIsGroupReplaceWay(0);
			planProductInfo.setStructureProductProp(
					productPropsService.getStructureProductPropValueByProductId(planProductInfo.getProductId(), ProductModelConstant.PRODUCTATTRCODE_QIANGM));
			planProductInfo.setInitProductCode(planProductInfo.getProductCode());
		}
		return planProductInfoList;
	}
	
	/**
	 * 结构白膜匹配单品/如果匹配不到则放到后面走单品搜索逻辑
	 * 
	 * @author huangsongbo
	 * @param planProductInfoList
	 * @param planProductInfoRecommendedList
	 * @param productListmap 推荐方案中的单品信息(用于结构之间的明细产品匹配失败,则当单品处理)
	 * @param productAttrCode 
	 * @param productList
	 * @return
	 */
	private List<PlanProductInfo> matchStructureProduct(List<PlanProductInfo> planProductInfoList,
			List<PlanProductInfo> planProductInfoRecommendedList, Map<String, List<PlanProductInfo>> productListmap, String productAttrCode) {
		// 参数验证 ->start
		if(Lists.isEmpty(planProductInfoList)) {
			return null;
		}
		if(Lists.isEmpty(planProductInfoRecommendedList)) {
			return null;
		}
		// 参数验证 ->end
		
		// 补充属性信息 ->start
		for(PlanProductInfo planProductInfoItem : planProductInfoRecommendedList) {
			planProductInfoItem.setStructureProductProp(productPropsService.getStructureProductPropValueByProductId(planProductInfoItem.getInitProductId(), productAttrCode));
			logger.debug("structureProductProp:" + planProductInfoItem.getStructureProductProp());
		}
		// 补充属性信息 ->end
		
		for(PlanProductInfo planProductInfo : planProductInfoList) {
			// 通过structureProductProp匹配
			
			boolean flag = this.matchStructureProductItem(planProductInfo, planProductInfoRecommendedList);
			if(flag) {
				
			}else {
				// 单品匹配
				this.matchStructureProductItem(planProductInfo, productListmap);
			}
		}
		return planProductInfoList;
	}
	
	private List<SplitTextureDTO> getSplitTexturesChooseInfoByPlanProductInfo(BaseProduct baseProduct) {
		String logSuffix = "function:IntelligenceDecorationServiceImpl.getSplitTexturesChooseInfoByPlanProductInfo -> ";
		// 参数验证 ->start
		if(baseProduct == null) {
			logger.error(logSuffix + "baseProduct = null");
			return null;
		}
		// 参数验证 ->end
		
		List<SplitTextureDTO> splitTextureDTOList = new ArrayList<SplitTextureDTO>();
		String materialIds = baseProduct.getMaterialPicIds();
		Integer materialId = 0;
		if (StringUtils.isNotBlank(materialIds)) {
			List<String> materialIdStrList = Utils.getListFromStr(materialIds);
			if (materialIdStrList != null && materialIdStrList.size() > 0) {
				materialId = Integer.valueOf(materialIdStrList.get(0));
			}
		}
		if (materialId != null && materialId > 0) {
			ResTexture resTexture = resTextureService.get(materialId);
			if (resTexture != null) {
				splitTextureDTOList = new ArrayList<SplitTextureDTO>();
				List<SplitTextureDTO.ResTextureDTO> resTextureDTOList = new ArrayList<SplitTextureDTO.ResTextureDTO>();
				SplitTextureDTO splitTextureDTO = new SplitTextureDTO("1", "", null);
				SplitTextureDTO.ResTextureDTO resTextureDTO = resTextureService.fromResTexture(resTexture);
				resTextureDTO.setKey(splitTextureDTO.getKey());
				resTextureDTO.setProductId(baseProduct.getId());
				resTextureDTOList.add(resTextureDTO);
				splitTextureDTO.setList(resTextureDTOList);
				splitTextureDTOList.add(splitTextureDTO);
			}
		}
		return splitTextureDTOList;
	}
	
	/**
	 * 样板房中的结构明细白膜和推荐方案中的结构明细匹配
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param planProductInfoRecommendedList
	 * @return
	 */
	private boolean matchStructureProductItem(PlanProductInfo planProductInfo,
			List<PlanProductInfo> planProductInfoRecommendedList) {
		// 参数验证 ->start
		
		// 参数验证 ->end
		
		// 匹配并补充属性 ->start
		for(PlanProductInfo planProductInfoItem : planProductInfoRecommendedList) {
			if(StringUtils.equals(planProductInfo.getStructureProductProp(), planProductInfoItem.getStructureProductProp())) {
				this.transferInfoWhenStructureProductMatched(planProductInfo, planProductInfoItem);
				return true;
			}
		}
		// 匹配并补充属性 ->end
		
		return false;
	}
	
	/**
	 * 结构按照单品匹配(大小类)
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param productListmap
	 */
	private void matchStructureProductItem(PlanProductInfo planProductInfo,
			Map<String, List<PlanProductInfo>> productListmap) {
		StringBuffer matchInfo = new StringBuffer();
		PlanProductInfo planProductInfoMatched = this.productListMatchDim(planProductInfo, productListmap.get(planProductInfo.getBigTypeValuekey()), matchInfo);
		this.transferInfoWhenStructureProductMatched(planProductInfo, planProductInfoMatched);
	}
	
	/**
	 * 当样板房结构白膜匹配到推荐方案结构白膜应用的贴图(产品)时,填充planProductInfo属性
	 * 
	 * @author huangsongbo
	 * @param planProductInfo
	 * @param planProductInfoItem
	 */
	private void transferInfoWhenStructureProductMatched(PlanProductInfo planProductInfo,
			PlanProductInfo planProductInfoItem) {
		// 参数验证 ->start
		if(planProductInfo == null) {
			return;
		}
		if(planProductInfoItem == null) {
			return;
		}
		// 参数验证 ->end
		
		planProductInfo.setProductId(planProductInfoItem.getProductId());
		planProductInfo.setBigTypeValuekey(planProductInfoItem.getBigTypeValuekey());
		planProductInfo.setSmallTypeValuekey(planProductInfoItem.getSmallTypeValuekey());
		planProductInfo.setProductCode(planProductInfoItem.getProductCode());
		planProductInfo.setProductLength(planProductInfoItem.getProductLength());
		planProductInfo.setProductWidth(planProductInfoItem.getProductWidth());
		planProductInfo.setProductHeight(planProductInfoItem.getProductHeight());
		planProductInfo.setStyleId(planProductInfoItem.getStyleId());
		planProductInfo.setMatchedPosName(planProductInfoItem.getPosName());
	}
	
	private PlanProductInfo getPlanProductInfoFromDesignTempletProduct(DesignTempletProduct designTempletProduct) {
		PlanProductInfo planProductInfo = new PlanProductInfo();
		planProductInfo.setProductId(designTempletProduct.getProductId());
		planProductInfo.setBigTypeValuekey(designTempletProduct.getBigTypeValuekey());
		planProductInfo.setSmallTypeValuekey(designTempletProduct.getSmallTypeValuekey());
		planProductInfo.setPosName(designTempletProduct.getPosName());
		planProductInfo.setBigTypeValuekeyInit(designTempletProduct.getBigTypeValuekey());
		planProductInfo.setSmallTypeValuekeyInit(designTempletProduct.getSmallTypeValuekey());
		planProductInfo.setProductCode(designTempletProduct.getProductCode());
		planProductInfo.setProductLength(designTempletProduct.getProductLength());
		planProductInfo.setProductWidth(designTempletProduct.getProductWidth());
		planProductInfo.setProductHeight(designTempletProduct.getProductHeight());
		planProductInfo.setRegionMark(designTempletProduct.getRegionMark());
		planProductInfo.setFullPaveLength(designTempletProduct.getFullPaveLength());
		planProductInfo.setWallOrientation(designTempletProduct.getWallOrientation());
		planProductInfo.setWallType(designTempletProduct.getWallType());
		planProductInfo.setIsMainProduct(designTempletProduct.getIsMainProduct());
		planProductInfo.setPlanGroupId(designTempletProduct.getPlanGroupId());
		planProductInfo.setCenter(designTempletProduct.getCenter());
		planProductInfo.setMeasureCode(designTempletProduct.getMeasureCode());
		planProductInfo.setPlanProductId(designTempletProduct.getId());
		planProductInfo.setInitProductId(designTempletProduct.getProductId());
		planProductInfo.setBindParentProductId(designTempletProduct.getBindParentProductId());
		planProductInfo.setCenter(designTempletProduct.getCenter());
		planProductInfo.setGroupOrStructureId(designTempletProduct.getProductGroupId());
		planProductInfo.setGroupType(designTempletProduct.getGroupType());
		planProductInfo.setIsMainStructureProduct(designTempletProduct.getIsMainStructureProduct());
		planProductInfo.setIsGroupReplaceWay(designTempletProduct.getIsGroupReplaceWay());
		planProductInfo.setProductIndex(designTempletProduct.getProductIndex());
		planProductInfo.setProductSmallpoxIdentify(designTempletProduct.getProductSmallpoxIdentify());
		planProductInfo.setPosIndexPath(designTempletProduct.getPosIndexPath());
		return planProductInfo;
	}
	
}